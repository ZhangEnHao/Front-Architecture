## 介绍

1. 旧接口格式和使用者不兼容

2. 中间加一个适配转换接口

```JavaScript
class Adaptee {
  specificRequest() {
    return `德国标准`
  }
}

class Target {
  constructor() {
    this.adaptee = new Adaptee();
  }
  request() {
    let info = this.adaptee.specificRequest();
    return `${info} —— 适配器 —— 中国标准`
  }
}

let target = new Target();
let res = target.request();
console.log(res);

```

## 场景

1. 封装旧接口

```JavaScript
// 自己封装的 ajax ，使用方法如下：
ajax({
  url: "/getData",
  type: "POST",
  dataType: "JSON",
  data: { id: "123" },
  success: (data) => {
    
  }
})
.done(function() {});

// 历史原因，代码中全部都是
// $.ajax({...})

// 适配器
let $ = {
  ajax: function(options) {

    return ajax(options);
  }
}

```

2. Vue Computed

```HTML
<div id="app">
  <p>顺序：{{ message }}</p>
  <p>逆序：{{ reversedMessage }}</p>
</div>
<script src="vue.js" />
```
```JavaScript
let vm = new Vue({
  el: "#app",
  data: {
    message: "hello"
  },
  computed: {
    reversedMessage: function() {
      return this.message.split("").reverse().join("");
    }
  }
})
```


## 设计原则验证

- 将旧接口和使用者进行分离

- 符合开放封闭原则


## eg

```JavaScript
$.ajax({
  url: isAll === 'all' ? `/agilesupply/chModel/list/all` : `/agilesupply/chModel/list`,
  type: 'GET',
  data: tmp,
  success(res) {
      if(res.code === 0) {
          let dataSource = res.data.content;
          for(let i = 0; i < dataSource.length; i++) {
              dataSource[i].key = i;
          };
          that.setState({
              total: res.data.totalElements,
              dataSource,
              loading: false
          })
      }else {
          message.destroy();
          message.error(res.message);
          that.setState({loading: false});
      }
  },
  error (res) {
      message.destroy();
      message.error(res.statusText);
      that.setState({loading: false});
  }
})

/**********    待验证    ***********/ 

function ajax(url, data = {}, method = 'GET', callbackBySuccess, callbackByError) {
  axios.interceptors.request.use(config=>{ // 请求之前加loading
    TopProgress.start();
    return config
  },error=>{
    return Promise.reject(error)
  })
  axios.interceptors.response.use(config=>{ // 响应成功关闭loading
    TopProgress.done();
    return config
  },error=>{
    TopProgress.done();
    return Promise.reject(error)
  })
  
  return new Promise((resolve, reject) => {
    let promise
    // 1. 执行异步ajax请求
    if (method === 'GET') {
      promise = axios.get(url, {
        params: data
      })
    } else if (method === 'POST') {
      promise = axios.post(url, data)
    } else if (method === 'PUT') {
      promise = axios.put(url, data)
    } else if (method === 'DELETE') {
      promise = axios.delete(url, {data})
    }

    // 2. 如果成功了, 调用 resolve(value)
    promise.then(response => {
      if(response.data.code === "401") {
        message.error("401)
      }else {
        resolve(callbackBySuccess(response.data));
      }
      // 3. 如果失败了 不调用 reject(reason) 而是提示异常信息
    }).catch(error => {
      typeof callbackByError === "function" && callbackByError(error)
    })
  })
}

$.ajax = function(options) {
  let { url, type, data, success, error } = options;
  return ajax(url, data, type, success, error);
};

$.post = $.POST = function(options) {
  let { url, type, data, success, error } = options;
  return ajax(url, data, "POST", success, error);
};

$.get = $.GET = function(options) {
  let { url, type, data, success, error } = options;
  return ajax(url, data, "GET", success, error);
};


```
