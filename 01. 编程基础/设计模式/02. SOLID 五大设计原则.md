具体来说，一个好的业务设计应该有这么几个特点：

- 易于扩展

- 易于修改

- 易于删除

代码指标：

1. 健壮性：代码面对无法控制的错误情况下，应对错误的能力，可以理解为现实中面对意外情况的应对能力。

2. 可读性：代码结构简洁清晰，容易阅读。

3. 可扩展性：面对功能的变更和修改，代码可以清晰且方便的扩展。不会因为修改引起代码的混乱和大规模重写。

4. 复用性：可重复使用性。

`SOLID` 面向对象编程的原则，其最佳实践就是 23 种设计模式了。他们为了解决的是软件工程中一个难题：**高内聚，低耦合**。

随着 `TS` 的流行，前端也开始有了继承，接口，抽象类，半残废的强类型检测等概念，`SOLID` 原则也开始在前端有一定的用武之地了。

## 内聚与耦合

### 内聚

1. 定义

度量一个模块内部各个元素彼此结合的紧密程度。

2. 类别（内聚性由低到高排列）

- 1. 偶然内聚：指一个模块内的各处理元素之间没有任何联系。（类似于把一推不相关的代码都组合在一个类里）

- 2. 逻辑内聚：指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。（类似于完成加法运算，有多个加法运算代码块，分别处理参数为 `int` 或 `float` 或 `double` 等。这些代码块之所以聚在一起，只是它们都是为了完成加法运算而已）

- 3. 时间内聚：指把需要同时执行的动作组合在一起形成的模块。（类似于利用抽象工厂模式生成一碗粥，你可以先放水，也可以先放米，这两个动作之间没有必然的顺序，但为了生成一碗粥，需要同时执行这两个动作）

- 4. 过程内聚：指一个模块完成多个任务，这些任务必须按照指定的过程执行。（类似于利用原生 `JDBC` 操纵数据库。你需要先连接 `JDBC` 获得 `connection` 对象，然后才能创建 `Statement` 对象，最后才能执行 `sql` 语句）

- 5. 通信内聚：指模块内的所有处理元素都在同一个数据结构上操作，或者各处理使用相同的输入数据或者产生相同的输出数据。（类似于有一个数组，你只把它作为你遍历数组，增加数组节点，删除数组节点的参数）

- 6. 顺序内聚：指一个模块中的各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素的输出就是下一功能元素的输入。（类似于程序模拟车间生产的某条流水线）

- 7. 功能内聚：指模块内的所有元素共同作用完成一个功能，缺一不可。（类似于某排序算法的代码，不能缺少任意一行代码，否则整个排序功能失效）

也就是说，模块功能越单一，内聚性就越高，模块的独立性就越强。一个模块应该做好一个功能就可以了，不要面面俱到，不然难以维护。

### 耦合

1. 定义

度量模块之间互相连接的紧密程度。

2. 类别：（耦合性由低到高排列）

- 1. 无直接耦合：指两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，它们之间不传递任何消息。

- 2. 数据耦合：指两个模块之间有调用关系，传递的是简单的数据值。（类似于高级语言中的值传递）

- 3. 标记耦合：指两个模块之间传递的是数据结构。（类似于高级语言中的引用传递）

- 4. 控制耦合：指一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值有选择地执行模块内的某一功能。因此，被调用模块应具有多个功能，哪个功能起作用受调用模块控制。（类似于计算工资模块，调用它的模块先区别是普通员工还是经理，进而生成控制变量，传递给计算工资模块进而选择其中一种计算功能）

- 5. 外部耦合：模块间通过软件之外的环境联结。（如 `I/O` 将模块耦合到特定的设备、格式、通信协议上）

- 6. 公共耦合：指通过一个公共数据环境相互作用的那些模块间的耦合。（例如某一模块把用户放到 `http session` 后，另外一些模块需要从 `http session` 取用户，那么它们之间就形成了公共耦合。如果必须存在公共耦合，应限制公共耦合的范围）

- 7. 内容耦合：当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部时。（类似于 `Java` 中不通过方法操作另一个类的数据，而是直接以类似于 `People.foot` 那样访问。）

也就是说，模块之间联系少，耦合性就越低，模块之间的相对独立性就越强。模块应该管理好自己的事情就可以了，这样即不会太复杂，也便于专注的完成自己的事情。微服务的思想也是这样。

对于耦合，如果模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，限制使用公共耦合的范围，坚决避免使用内容耦合。

## SOLID

设计模式其实是针对面向对象编程范式总结出来的解决方案，所以设计模式的原则都是围绕“类”和“接口”这两个概念来提出的，其中下面 `SOLID` 原则非常重要，因为 `SOLID` 原则决定了设计模式的规范和标准。

在面向对象设计中 `SOLID` 五大设计原则可以保证代码具备：稳定性、灵活性、健壮性和可维护性。

`SOLID` 是 `SRP`、`OCP`、`LSP`、`ISP` 和 `DIP` 的首字母缩写组成，接下来看一下 `SOLID` 的具体含义：

- `Single Responsibility Principle`（单一职责原则）

- `Open Closed Principle`（开闭原则）

- `Liskov Substitution Principle`（里氏替换原则）

- `Interface Segregation Principle`（接口隔离原则）

- `Dependency Inversion Principle`（依赖倒置原则）

SOLID 原则的三大法宝：

- 1. 接口/抽象类

- 2. 组合

- 3. 反射 /泛型

### Single Responsibility Principle（SRP）：单一职责原则

一个类或者一个模块只做一件事，只负责单一功能。

职责可以理解为“变动的原因”。`SRP` 即为应该有且仅有一个原因引起类的变更。

适当的拆分，考验的是开发者的抽象能力，以及对业务的理解能力。在两者之间进行权衡，开发者的大部分时间，其实都是在做权衡，没有最好的，只有最合适的。

拆分的代码，单一职责的代码行数超过了 100 行，就应该考虑继续拆分。

选择合适的拆分粒度之后，就可以进行实践了。

一般来说，最佳实践有以下几种方式，

- 使用基于接口的组合

- 策略模式，策略模式其实也是基于接口的组合的一种，只是它组合的接口，实现的方式可能有点多。使用策略模式，可以很好的清掉代码中的 `If else` 和 `switch` 分支。

- 装饰者模式，`Spring` 中的 `AOP`，`React` 中的 `HOC`，`ES6` 中的 `deractor`，最常见的还是 `HTTP` 协议的实现。

思考：为什么大家提倡组合，而不是继承？

### Open Closed Principle（OCP）：开闭原则

实体应该对扩展是开放的，对修改是封闭的。君子纳于言而敏于行，模块纳于改代码而敏于扩展。

总的来说，就是当增加一个新功能的时候，尽量在不修改既有代码的情况下，来进行扩展。使用增加代码的方式，如新的类或新的方法来实现新功能。

体现在实践当中，就是类和模块之间的依赖，应该基于接口，而不是具体的实现。应该基于父类，而不是子类。

前端有一个实践，有点类似这种思想:`VUE` 的 `Slot`。

### Liskov Substitution Principle（LSP）：里氏替换原则

所有基类出现的地方都可以用派生类替换而不会让程序产生错误，派生类可以扩展基类的功能，但不能改变基类原有的功能。

里氏替换原则通俗的来讲就是：子类对象能够替换其基类对象被使用；引申开来就是子类可以扩展父类的功能，但不能改变父类原有的功能。子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

根据上述理解，对里氏替换原则的定义可以总结如下：

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法

- 子类中可以增加自己特有的方法

- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松

- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。

需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。

### Interface Segregation Principle（ISP）：接口隔离原则

一个接口应该拥有尽可能少的行为，使其精简单一。对于不同的功能的模块分别使用不同接口，而不是使用同一个通用的接口。通俗的讲是使用者不应该被迫依赖于它不使用的方法/接口。

接口隔离原则最重要的就是，从使用者角度出发定义接口方法。

回到具体的设计层面来说，如果接口功能过多，非常容易违反单一职责。

对于具体编码来说，就是从调用方的需求出发，需要调用什么，就提供什么。

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：

- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。

- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

### Dependence Inversion Principle（DIP）：依赖倒置原则

核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；

通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，互不影响，实现模块间的松耦合。

高层模块不依赖低层模块，它们共同依赖同一个抽象（接口），这个抽象接口通常是由高层模块定义，低层模块实现。同时抽象不要依赖具体实现细节，具体实现细节依赖抽象。高层模块就是调用端，低层模块就是具体实现类，抽象就是指接口或抽象类，细节就是实现类。

好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。

### 补充：迪米特原则

一个类对于其他类知道得越少越好，就是说一个对象应当对其他对象尽可能少的了解。

这一条原则要求任何一个对象或者方法只能调用该对象本身和内部创建的对象实例，如果要调用外部的对象，只能通过参数的形式传递进来。这一点和纯函数的思想相似。

## 总结

`SOLID` 一句话概括就是:单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；接口隔离原则告诉我们在设计接口的时候要精简单一；依赖倒置原则告诉我们要面向接口编程。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。

在实际开发过程中，并不是一定要求所有代码都遵循设计原则，要考虑人力、时间、成本、质量，不是刻意追求完美，要在适当的场景遵循设计原则，体现的是一种平衡取舍，帮助我们设计出更加优雅的代码结构。
