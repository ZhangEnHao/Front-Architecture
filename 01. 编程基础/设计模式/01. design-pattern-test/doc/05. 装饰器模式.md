## 介绍

1. 给对象添加新功能

2. 不改变原有的结构和功能

```JavaScript
class Circle {
  draw() {
    console.log(`画一个圆形`);
  }
}

class Decorator {
  constructor(circle) {
    this.circle = circle
  }
  draw() {
    this.circle.draw();
    this.setRedBorder(this.circle);
  }
  setRedBorder(circle) {
    console.log(`加一个红色边框`);
  }
}


// test 

let circle = new Circle();
circle.draw();

console.log(`----------------`);

let dec = new Decorator(circle);
dec.draw();

```

## 场景

1. ES7 装饰器

- 作用于类的装饰器

```JavaScript
@log
class MyClass { }

function log(target) { // 这个 target 在这里就是 MyClass 这个类
   target.prototype.logger = () => `${target.name} 被调用`
}

const test = new MyClass()
console.log(test.logger()); // MyClass 被调用
```

装饰器原理：
```JavaScript
@decorator
class A {}
// 等同于
class A {}

A = decorator(A) || A;
```

- 装饰器可传参

```JavaScript
@log('hi')
class MyClass { }

function log(text) {
  return function(target) {
    target.prototype.logger = () => `${text}，${target.name} 被调用`
  }
}

const test = new MyClass()
test.logger() // hello，MyClass 被调用
```

- mixins

```JavaScript
function mixins(...list) {
  return function(target) {
    Object.assign(target.prototype, ...list)
  }
}

const Foo = {
  foo: () => alert(`foo`)
}

@mixins(Foo)
class MyClass {}

let obj = new MyClass();
obj.foo()
```

- 作用于类方法的装饰器

```JavaScript
class C {
  @readonly(false)
  method() { console.log('cat') }
}

function readonly(value) {
  return function (target, key, descriptor) { // 此处 target 为 C.prototype; key 为 method;
    // 原 descriptor 为：{ value: f, enumarable: false, writable: true, configurable: true }
    descriptor.writable = value
    return descriptor
  }
}

const c = new C()
c.method = () => console.log('dog')

c.method() // cat

```

```JavaScript
@log('hi')
class MyClass { }

function log(text) {
  return function(target) {
    target.prototype.logger = () => `${text}，${target.name} 被调用`
  }
}

const test = new MyClass()
console.log(test.logger()); // hi，MyClass 被调用
```

[JS 装饰器解析](https://www.jianshu.com/p/56e41f3533de )

2. core-decorators


## 设计原则验证

- 将原有对象和装饰器进行分离，两者独立存在

- 符合开放封闭原则