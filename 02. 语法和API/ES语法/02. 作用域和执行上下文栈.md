## 作用域

作用域是指程序源代码中定义变量的区域。

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

`JavaScript` 采用词法作用域(lexical scoping)，也就是静态作用域。

作用域其实可理解为该上下文中声明的变量和声明的作用范围。可分为 全局作用域、 函数作用域和块级作用域。

函数的作用域基于函数创建的位置，在函数定义的时候就决定了。

作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

## 执行上下文 —— 可执行代码

在一段 js 代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”：

- 变量、函数表达式 —— 变量声明，默认赋值为`undefined`；

- `this` —— 赋值；

- 函数声明 —— 赋值。**函数在定义的时候确定函数体内部自由变量的作用域**。

这些“准备工作”即为执行上下文[环境]，是当前 `JavaScript` 代码被解析和执行时所在环境的抽象概念。

`JavaScript` 的可执行代码(executable code)的类型有三种，全局代码、函数代码、eval 代码。

当 `JavaScript` 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

- 全局执行上下文：只有一个，浏览器中的全局对象就是 `window` 对象，`this` 指向这个全局对象。即全局执行上下文为手写文本到`<script>`标签里面的。

- 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次**调用函数都会创建一个新的执行上下文**。

- `Eval` 函数执行上下文： 指的是运行在 `eval` 函数中文本形式的代码，很少用而且不建议使用。

为了管理创建执行上下文， `JavaScript` 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。

## 执行上下文栈

执行上下文栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。

首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行上下文栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行上下文栈的栈顶。

根据执行上下文栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行上下文栈中Pop出，上下文控制权将移到当前执行上下文栈的下一个执行上下文。

通俗而言：执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。

其实这是一个压栈出栈的过程 —— 执行上下文栈。

![执行上下文栈](./images/执行上下文栈.jpeg)



## 从【自由变量】到【作用域链】

1. 什么是“自由变量”

在 A 作用域中使用的变量 x，却没有在 A 作用域中声明（即在其他作用域中声明的），对于 A 作用域来说，x 就是一个自由变量。

自由变量要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”。—— 其实这就是所谓的“静态作用域”。

2. 作用域链： 取自由变量时的一步一步“跨”的路线

“作用域链”过程：

- 第一步，现在当前作用域查找自由变量，如果有则获取并结束。如果没有则继续；

- 第二步，如果当前作用域是全局作用域，则证明自由变量未定义，结束；否则继续；

- 第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；

- 第四步，跳转到第一步。

作用域链和原型继承查找时的区别：如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回 undefined；但查找的属性在作用域链中不存在的话就会抛出 ReferenceError。

作用域链的顶端是全局对象，在全局环境中定义的变量就会绑定到全局对象中。
