## 介绍

- 发布 & 订阅

- 一对多

最重要

```JavaScript
// 主题 保存状态 状态变化之后触发所有观察者对象
class Subject {
  constructor() {
    this.state = 0;
    this.observers = [];
  }
  getState() {
    return this.state
  }
  setState(state) {
    this.state = state;
    this.notifyAllObservers();
  }
  notifyAllObservers() {
    this.observers.forEach(observer => {
      observer.update();
    })
  }
  attach(observer) {
    this.observers.push(observer);
  }
}

// 观察者
class Observer {
  constructor(name, subject) {
    this.name = name;
    this.subject = subject;
    this.subject.attach(this);
  }
  update() {
    console.log(`${this.name} state - ${this.subject.getState()}`);
  }
}

let s = new Subject();

let o1 = new Observer("o1", s);
let o2 = new Observer("o2", s);
let o3 = new Observer("o3", s);
s.setState(1);
s.setState(2);
s.setState(3);
```

## 场景

1. 网页事件绑定

2. Promis

3. JQuery callbacks

```JavaScript
let callbacks = $.Callbacks();
callbacks.add(function(info) {
  console.log("fn1", info)
})
callbacks.add(function(info) {
  console.log("fn2", info)
})
callbacks.add(function(info) {
  console.log("fn3", info)
})

callbacks.fire("gogogo")
callbacks.fire("fire")
```

4. nodejs 自定义事件

5. 其他场景

  - nodejs 中：处理 http 请求；多进程通讯

  - vue 和 React 组件生命周期触发

  - vue watch

## 设计原则验证

- 主题和观察者分离，不是主动触发而是被动监听，两者解耦

- 符合开放封闭原则


## 创建一个观察者

```JavaScript
const Observe = (function () {
  //防止消息队列暴露而被篡改，将消息容器设置为私有变量
  let __message = {};
  return {
    //注册消息接口
    on : function (type, fn) {
      //如果此消息不存在，创建一个该消息类型
      if( typeof __message[type] === 'undefined' ){
        // 将执行方法推入该消息对应的执行队列中
        __message[type] = [fn];
      }else{
        //如果此消息存在，直接将执行方法推入该消息对应的执行队列中
        __message[type].push(fn);
      }
    },
    //发布消息接口
    subscribe: function (type, args) {
    	//如果该消息没有注册，直接返回
    	if ( !__message[type] )  return;
    	//定义消息信息
    	let events = {
        	type: type,           //消息类型
        	args: args || {}      //参数
        },
        i = 0,                         // 循环变量
        len = __message[type].length;  // 执行队列长度
    	//遍历执行函数
    	for ( ; i < len; i++ ) {
    		//依次执行注册消息对应的方法
        __message[type][i].call(this,events)
    	}
    }
    //移除消息接口
    off: function (type, fn) {
    	//如果消息执行队列存在
    	if ( __message[type] instanceof Array ) {
    		// 从最后一条依次遍历
    		let i = __message[type].length - 1;
    		for ( ; i >= 0; i-- ) {
    			//如果存在改执行函数则移除相应的动作
    			__message[type][i] === fn && __message[type].splice(i, 1);
    		}
    	}
    }
  }
})();

```
