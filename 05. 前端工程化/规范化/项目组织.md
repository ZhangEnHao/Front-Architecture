## multirepo

multirepo 就是将项目中的模块拆分出来，放在不同的仓库中进行独立管理。例如，用于 Node.js 的 Web 框架 `Koa`，它依赖的模块 `koa-convert` 和 `koa-compose` 分别拆分成了两个仓库进行管理。

这种方式的好处是保证仓库的独立性，方便不同团队维护对应的仓库代码，可以根据团队情况选择擅长的工具、工作流等。

但这种方式也会存在一些问题，具体如下。

1. 开发调试及版本更新效率低下。比如在仓库 A 用到的仓库 B 中发现了一个 bug，就必须到仓库 B 里修复它、打包、发版本，然后再回到仓库 A 继续工作。在不同的仓库间，你不仅需要处理不同的代码、工具，甚至是不同的工作流程；还有，你只能去问维护这个仓库的人，能不能为你做出改变，然后等着他们去解决。

2. 团队技术选型分散。不同的库实现风格可能存在较大差异（比如有的库依赖 Vue，有的依赖 React），还有可能会采用不同的测试库及校验规则，维护起来比较困难。

## monorepo

monorepo 就是将所有相关的模块放在同一个项目仓库中。这种方式在管理上会更加方便，项目所有代码可以使用统一的规范及构建、测试、发布流程。

很多著名的开源项目都采取了这种管理方式，比如开源项目 `babel`，它依赖的模块都放在了 `packages` 目录下。

通过查看 `babel` 项目，发现根目录下有一个 `lerna.json` 的配置文件，这是开源工具 `lerna` 的配置文件。`lerna` 是一个用于管理带有多个包的 JavaScript 项目工具，用 `lerna` 管理的项目会有 3 个文件目录：`packages` 目录、`learna.json` 文件和 `package.json` 文件。通过 `lerna` 命令行工具在初始化项目的时候就可以创建它们。

`lerna` 支持两种模式，分别是 `Fixed/Locked` 和 `Independent` 模式。

`Fixed/Locked` 模式为默认模式，`babel` 采用的就是这种模式，该模式的特点是，开发者执行 `lerna publish` 后，`lerna` 会在 `lerna.json` 中找到指定 `version` 版本号。如果这一次发布包含某个项目的更新，那么会自动更新 `version` 版本号。对于各个项目相关联的场景，这样的模式非常有利，任何一个项目大版本升级，其他项目的大版本号也会更新。

`Independent` 模式顾名思义，各个项目都是相互独立。开发者需要独立管理多个包的版本更新。也就是说，我们可以具体到更新每个包的版本。每次发布，`lerna` 会配合 `Git`，检查相关包文件的变动，只发布有改动的 `package`。

虽然众多开源项目采用了 `monorepo`，但它也并不是最完美的代码组织方式，也会带来一些问题，比如由于将多个模块集中在一个仓库中会导致仓库体积变大，目录结构也会变得更复杂。而 `monorepo` 也需要额外的工具来管理各个模块，这意味着相对 `multirepo` 而言会有一定的学习成本。
