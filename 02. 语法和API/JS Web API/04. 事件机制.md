### 事件处理函数的执行顺序

重复绑定特性，需要遵循以下执行顺序：
  addEventListener和attachEvent表现一致,如果给同一个事件绑定多个处理函数，先绑定的先执行。

```html
  <script>
    window.onload = function(){
      var outA = document.getElementById("outA"); 
      outA.addEventListener('click',function(){alert(1);},false);
      outA.addEventListener('click',function(){alert(2);},true);
      outA.addEventListener('click',function(){alert(3);},true);
      outA.addEventListener('click',function(){alert(4);},true);
    }
  </script>
  <body>
    <div id="outA" style="width:400px; height:400px; background:#CDC9C9;position:relative;"></div>
  </body>
```
当点击outA的时候，会依次打印出1、2、3、4。这里特别需要注意：我们给outA绑定了多个onclick事件处理函数，也是直接点击outA触发的事件，所以不涉及事件冒泡和事件捕获的问题，即addEventListener的第三个参数在这种场景下，没有什么用处。

### 事件冒泡和事件捕获

**事件捕获（event capturing）**： 通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。

**事件冒泡（dubbed bubbling）**： 与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播，它就像一跟引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆， 试想一下，如果引线不导火了，那鞭炮就只有一响了！！！

事件冒泡和事件捕获很好理解，只不过是对同一件事情的不同看法，只不过这2种看法都很有道理。

我们知道HTML中的元素是可以嵌套的，形成类似于树的层次关系。比如下面的代码：

```html
  <div id="outA" style="width:400px; height:400px; background:#CDC9C9;position:relative;">
    <div id="outB" style="height:200; background:#0000ff;top:100px;position:relative;">
      <div id="outC" style="height:100px; background:#FFB90F;top:50px;position:relative;"></div>
    </div>
  </div>
```

如果点击了最内侧的outC，那么外侧的outB和outC算不算被点击了呢？很显然算，不然就没有必要区分事件冒泡和事件捕获了，这一点各个浏览器厂家也没有什么疑义。

假如outA、outB、outC都注册了click类型事件处理函数，当点击outC的时候，触发顺序是A-->B-->C，还是C-->B-->A呢？如果浏览器采用的是事件冒泡，那么触发顺序是C-->B-->A，由内而外，像气泡一样，从水底浮向水面；如果采用的是事件捕获，那么触发顺序是A-->B-->C，从上到下，像石头一样，从水面落入水底。

一般来说事件冒泡机制，用的更多一些，所以在IE8以及之前，IE只支持事件冒泡。

IE9+/FF/Chrome这2种模型都支持，可以通过addEventListener((type, listener, useCapture)的useCapture来设定，useCapture=false代表着事件冒泡，useCapture=true代表着采用事件捕获。

```html
  <script>
    window.onload = function(){
      var outA = document.getElementById("outA"); 
      var outB = document.getElementById("outB"); 
      var outC = document.getElementById("outC"); 

      // 使用事件冒泡
      outA.addEventListener('click',function(){alert(1);},false);
      outB.addEventListener('click',function(){alert(2);},false);
      outC.addEventListener('click',function(){alert(3);},false);
    };
  </script>
  <div id="outA" style="width:400px; height:400px; background:#CDC9C9;position:relative;">
    <div id="outB" style="height:200; background:#0000ff;top:100px;position:relative;">
      <div id="outC" style="height:100px; background:#FFB90F;top:50px;position:relative;"></div>
    </div>
  </div>
```

使用的是事件冒泡，当点击outC的时候，打印顺序是3-->2-->1。如果将false改成true使用事件捕获，打印顺序是1-->2-->3。

### DOM事件流

**DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。先调用捕获阶段的处理函数，其次调用目标阶段的处理函数，最后调用冒泡阶段的处理函数。**

```html
<script>
  window.onload = function(){
    var outA = document.getElementById("outA"); 
    var outB = document.getElementById("outB"); 
    var outC = document.getElementById("outC"); 
    // 目标(自身触发事件,是冒泡还是捕获无所谓)
    outC.addEventListener('click',function(){alert("target");},true);
    // 事件冒泡
    outA.addEventListener('click',function(){alert("bubble1");},false);
    outB.addEventListener('click',function(){alert("bubble2");},false);
    // 事件捕获
    outA.addEventListener('click',function(){alert("capture1");},true);
    outB.addEventListener('click',function(){alert("capture2");},true); 
  };
</script>
<body>
  <div id=“outA” style=“width:400px; height:400px; background:#CDC9C9;position:relative;”>
    <div id=“outB” style=“height:200; background:#0000ff;top:100px;position:relative;”>
      <div id=“outC” style=“height:100px; background:#FFB90F;top:50px;position:relative;”></div>
    </div>
  </div>
</body>
```

当点击outC的时候，依次打印出capture1-->capture2-->target-->bubble2-->bubble1。到这里是不是可以理解addEventListener(type,handler,useCapture)这个API中第三个参数useCapture的含义呢？

useCapture=false意味着：将事件处理函数加入到冒泡阶段，在冒泡阶段会被调用；

useCapture=true意味着：将事件处理函数加入到捕获阶段，在捕获阶段会被调用。

从DOM事件流模型可以看出，捕获阶段的事件处理函数，一定比冒泡阶段的事件处理函数先执行。


### 再谈事件函数执行先后顺序

在DOM事件流中提到过：

// 目标(自身触发事件,是冒泡还是捕获无所谓)

outC.addEventListener('click',function(){alert("target");},true);

我们在outC上触发onclick事件(这个是目标对象)，如果我们在outC上同时绑定捕获阶段/冒泡阶段事件处理函数会怎么样呢？

```html
<script>
  window.onload = function(){
    var outA = document.getElementById("outA"); 
    var outB = document.getElementById("outB"); 
    var outC = document.getElementById("outC"); 
    // 目标(自身触发事件,是冒泡还是捕获无所谓)
    outC.addEventListener('click',function(){alert("target2");},true);
    outC.addEventListener('click',function(){alert("target1");},true);
    // 事件冒泡
    outA.addEventListener('click',function(){alert("bubble1");},false);
    outB.addEventListener('click',function(){alert("bubble2");},false);
    // 事件捕获
    outA.addEventListener('click',function(){alert("capture1");},true);
    outB.addEventListener('click',function(){alert("capture2");},true); 
  };
</script>
<body>
  <div id=“outA” style=“width:400px; height:400px; background:#CDC9C9;position:relative;”>
    <div id=“outB” style=“height:200; background:#0000ff;top:100px;position:relative;”>
      <div id=“outC” style=“height:100px; background:#FFB90F;top:50px;position:relative;”></div>
    </div>
  </div>
</body>
```

点击outC的时候，打印顺序是:capture1-->capture2-->target2-->target1-->bubble2-->bubble1。

由于outC是我们触发事件的目标对象，在outC上注册的事件处理函数，属于DOM事件流中的目标阶段。

目标阶段函数的执行顺序：先注册的先执行，后注册的后执行。这就是上面我们说的，在目标对象上绑定的函数是采用捕获，还是采用冒泡，都没有什么关系，因为冒泡和捕获只是对父元素上的函数执行顺序有影响，对自己没有什么影响。如果不信，可以将下面的代码放进去验证。

```javaScript
  // 目标(自身触发事件,是冒泡还是捕获无所谓)
  outC.addEventListener('click',function(){alert("target1");},false);
  outC.addEventListener('click',function(){alert("target2");},true);
  outC.addEventListener('click',function(){alert("target3");},true);
  outC.addEventListener('click',function(){alert("target4");},false);
```

至此我们可以给出事件函数执行顺序的结论了：捕获阶段的处理函数最先执行，其次是目标阶段的处理函数，最后是冒泡阶段的处理函数。目标阶段的处理函数，先注册的先执行，后注册的后执行。

### 阻止事件冒泡和捕获

默认情况下，多个事件处理函数会按照DOM事件流模型中的顺序执行。如果子元素上发生某个事件，不需要执行父元素上注册的事件处理函数，那么我们可以停止捕获和冒泡，避免没有意义的函数调用。前面提到的5种事件绑定方式，都可以实现阻止事件的传播。

由于第5种方式，是最推荐的做法。所以我们基于第5种方式，看看如何阻止事件的传播行为。IE8以及以前可以通过 window.event.cancelBubble=true阻止事件的继续传播；IE9+/FF/Chrome通过event.stopPropagation()阻止事件的继续传播。

通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。

```html
<script>
  window.onload = function(){
    var outA = document.getElementById("outA"); 
    var outB = document.getElementById("outB"); 
    var outC = document.getElementById("outC"); 
    // 目标
    outC.addEventListener('click',function(event){
      alert("target");
      event.stopPropagation();
    },false);
    // 事件冒泡
    outA.addEventListener('click',function(){alert("bubble");},false);
    // 事件捕获
    outA.addEventListener('click',function(){alert("capture");},true);
  };
</script>
<body>
  <div id=“outA” style=“width:400px; height:400px; background:#CDC9C9;position:relative;”>
    <div id=“outB” style=“height:200; background:#0000ff;top:100px;position:relative;”>
      <div id=“outC” style=“height:100px; background:#FFB90F;top:50px;position:relative;”></div>
    </div>
  </div>
</body>
```

当点击outC的时候，之后打印出capture-->target，不会打印出bubble。因为当事件传播到outC上的处理函数时，通过stopPropagation阻止了事件的继续传播，所以不会继续传播到冒泡阶段。

最后再看一段更有意思的代码：

```html
<script>
  window.onload = function(){
    var outA = document.getElementById("outA"); 
    var outB = document.getElementById("outB"); 
    var outC = document.getElementById("outC"); 
    // 目标
    outC.addEventListener('click',function(event){alert("target");},false);
    // 事件冒泡
    outA.addEventListener('click',function(){alert("bubble");},false);
    // 事件捕获
    outA.addEventListener('click',function(){alert("capture");event.stopPropagation();},true); 

  };
</script>
<body>
  <div id=“outA” style=“width:400px; height:400px; background:#CDC9C9;position:relative;”>
    <div id=“outB” style=“height:200; background:#0000ff;top:100px;position:relative;”>
      <div id=“outC” style=“height:100px; background:#FFB90F;top:50px;position:relative;”></div>
    </div>
  </div>
</body>
```

执行结果是只打印capture，不会打印target和bubble。

