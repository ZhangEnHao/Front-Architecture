删除节点要从查找要删的节点开始, 找到节点后, 需要考虑三种情况:

先保存了一些临时变量

current: 用于一会儿找到的要删除的节点对应的node.

parent: 用于保存current节点的父节点. 因为如果current有子节点, 那么在删除current节点的时候, 必然需要将parent的left或者right指向它的某一个子节点. 所以需要保存起来current的parent. (树中的节点关系不能向上的, 和链表非常相似)

isLeftChild: boolean类型,它用户记录我们是在current是在父节点的左侧还是右侧, 以便到时候设置parent的left或者right

1. 该节点是也节点(没有子节点)

- 检测 `current` 的 `left` 以及 `right` 是否都为 `null`.

- 都为 `null` 之后还要检测是否 `current` 就是根, 都为 `null`, 并且为根, 相当于要清空二叉树(当然, 只是清空了根, 因为只有它).

- 否则就把父节点的 `left` 或者 `right` 字段设置为 `null` 即可.

2. 该节点有一个子节点

- 要删除的 `current` 节点, 只有 `2` 个连接(如果有两个子节点, 就是三个连接了), 一个连接父节点, 一个连接唯一的子节点.

- 需要从这三者之间: 爷爷 - 自己 - 儿子, 将自己(`current`)剪短, 让爷爷直接连接儿子即可.

- 这个过程要求改变父节点的 `left` 或者 `right`, 指向要删除节点的子节点.

- 在这个过程中还要考虑是否 `current` 就是根.

3. 该节点有两个子节点

删除有两个节点的规律:

- 如果要删除的节点有两个子节点, 甚至子节点还有子节点, 这种情况下需要从下面的子节点中找到一个节点, 来替换当前的节点.

- 找到的这个节点特征应该是 `current` 节点下面所有节点中最接近 `current` 节点的.

- 要么比 `current` 节点小一点点, 要么比 `current` 节点大一点点.

- 总结你最接近 `current` , 你就可以用来替换 `current` 的位置.

这个节点怎么找呢?

- 比 `current` 小一点点的节点, 一定是 `current` 左子树的最大值.

- 比 `current` 大一点点的节点, 一定是 `current` 右子树的最小值.

前驱 & 后继

- 比 `current` 小一点点的节点, 称为 `current` 节点的前驱.

- 比 `current` 大一点点的节点, 称为 `current` 节点的后继.

- 也就是为了能够删除有两个子节点的 `current` , 要么找到它的前驱, 要么找到它的后继.

## 删除节点的回顾

删除节点相当棘手，一些程序员都尝试着避开删除操作

- 在Node类中添加一个boolean的字段, 比如名称为isDeleted.

- 要删除一个节点时, 就将此字段设置为true.

- 其他操作, 比如 find() 在查找之前先判断这个节点是不是标记为删除.

- 这样相对比较简单, 每次删除节点不会改变原有的树结构.

- 但是在二叉树的存储中, 还保留着那些本该已经被删除掉的节点.

这样的做法看起来很聪明, 其实是一种逃避，会造成很大空间的浪费, 特别是针对数据量较大的情况.
而且, 作为程序员要学会通过这些复杂的操作, 锻炼自己的逻辑, 而不是避重就轻.
