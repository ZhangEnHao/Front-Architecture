## 单页面模式（SPA，Single-Page Application）

`SPA`  即为  `single page application`  的缩写，意为单页面应用，其作为一种网页应用模型。一般也称为 `CSR`（Client Side Render），即客户端渲染。

简单来说，就是在同一个页面，通过 `ajax` 更新部分内容而非整个页面重新载入，达到较好的使用体验，并且可以节省网站资源。

只有一张 `Web` 页面的应用，是一种从 `Web` 服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(`html`、`js`、`css` 等)仅需加载一次，也就是不需刷新地动态加载。浏览器(`Client`)渲染顾名思义就是所有的页面渲染、逻辑处理、页面路由、接口请求均是在浏览器中发生。对于 SPA 来说，页面的切换就是视图之间的切换。常用于 `PC` 端官网、购物等网站。

1. 原理

`JS` 会感知到 `url` 的变化，通过这一点，可以用 `js` 动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求 `html` 文件。

2. 优点：速度和响应能力快

页面每次切换跳转时，服务器不必在每次交互时重新加载大多数资源，例如 HTML + CSS + 脚本 - 只需要初始加载。之后只从服务器下载新数据，在切换页面的时候速度很快。此外，SPA 仅重新加载特定的内容片段，因此它们的服务器负载更轻。

3. 缺点：首屏时间稍慢，`SEO` 差

因为首屏时需要请求一次 `HTML`，同时还需要发送一次 `js` 请求，两次请求回来了，首屏才会展示出来，相对于多页面应用，首屏时间稍慢。

`SEO` 效果差是因为搜索引擎只认识 `HTML` 里面的内容，不认识 `js` 渲染生成的内容，搜索引擎不识别，也就不会给一个好的排名，会导致单页面应用做出来的网页在搜索引擎上的排名差。

## 多页面模式（MPA，Multi-Page Application）

`MPA` 即为 `multiple page application` 的缩写，意为多页面应用模型，与 `SPA` 对比最大的不同即是页面路由切换由原生浏览器文档跳转（`navigating across documents`）控制。一般都是 `SSR` 全称 `Server Side Render`，服务器端渲染。服务端渲染则是在服务端完成页面的渲染，在服务端完成页面模板、数据填充、页面渲染，然后将完整的 `HTML` 内容返回给到浏览器。

1. 优点

- 多页面应用的首屏时间快。

当访问页面的时候，服务器返回一个 `html`，页面就会展示出来，这个过程只经历了一个 `HTTP` 请求，所以页面展示的速度非常快。

- 搜索引擎优化效果好（SEO）

搜索引擎在做网页排名的时候，要根据网页的内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别 html 内容的，而我们每个页面所有的内容都放在 `html` 中，所以这种多页应用 `SEO` 排名效果好。

2. 缺点：切换慢

因为每次跳转都需要发送一个 `HTTP` 请求，如果网络状态不好，在页面之间来回跳转时，就会发生明显的卡顿，影响用户体验。

## SPA 和 MPA 的区别

|                     | 单页面应用（SinglePage Web Application，SPA）                                                                                              | 多页面应用（MultiPage Application，MPA）                                                          |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------- |
| 组成                | 一个主页面 + 许多模块的组件成                                                                                                              | 多个完整页面                                                                                      |
| 跳转方式            | 一个页面片段删除或隐藏，加载另一个页面片段并显示。片段间的模拟跳转，没有离开外壳页面                                                       | 从一个页面到另一个页面                                                                            |
| html 文件请求       | 第一次进入页面的时候会请求一个 html 文件，刷新清除一下。切换到其他组件，此时路径也相应变化，但是并没有新的 html 文件请求，页面内容也变化了 | 每一次页面跳转的时候，后台服务器都会给返回一个新的 html 文档                                      |
| 资源共用(css 和 js) | 共用，组件公用的资源只需要加载一次                                                                                                         | 不共用，每个页面都要加载公用的资源                                                                |
| 首屏时间            | 首屏时间慢，首屏时需要请求一次 html，同时还要发送一次 js 请求，两次请求回来了，首屏才会展示出来                                            | 首屏时间快，访问页面的时候，服务器返回一个 html，页面就会展示出来，这个过程只经历了一个 HTTP 请求 |
| 刷新方式            | 页面局部刷新或更改                                                                                                                         | 整页刷新                                                                                          |
| url 模式            | a.com/#/pageone a.com/#/pagetwo                                                                                                            | a.com/pageone.html a.com/pagetwo.html                                                             |
| 路由模式            | 可以使用 hash ，也可以使用 history                                                                                                         | 普通链接跳转                                                                                      |
| 用户体验            | 页面片段间的切换快，用户体验良好，包括移动设备                                                                                             | 页面切换加载缓慢，流畅度不够，用户体验比较差，尤其是在移动端                                      |
| 转场动画            | 容易实现                                                                                                                                   | 无法实现                                                                                          |
| 页面间数据传递      | 容易（Vuex 或者 Vue 中的父子组件通信）                                                                                                     | 相对麻烦，依赖 url 传参、或者 cookie 、localStorage 等                                            |
| 搜索引擎优化(SEO)   | 需要单独方案、实现较为困难、不利于 SEO 检索 可利用服务器端渲染(SSR)优化                                                                    | 可以直接做                                                                                        |
| 适用范围            | 高要求的体验度、追求界面流畅的应用                                                                                                         | 适用于追求高度支持搜索引擎的应用                                                                  |
| 开发成本            | 较高，常需借助专业的框架来降低这种模式的开发难度                                                                                           | 较低 ，但页面重复代码多                                                                           |
| 维护成本            | 相对容易                                                                                                                                   | 相对复杂                                                                                          |

## 如何选择使用 `SPA` 还是 `MPA`

`SPA` 更加注重于接近原生应用的体验，基于代码组件的可复用特性，使得开发效率和成本方面具有得天独厚的优势，所以 `SPA` 更加适合开发有快速迭代需求的应用。而且基于可复用组件的特点，应用虽然在初始化时的成本高于 `MPA`，但其页面切换之间的成本是明显小于 `MPA` 的切换成本。虽然 `SPA` 因其架构特点导致其初始化成本高，但可以通过动态加载异步组件来显著降低 `SPA` 应用的初始化成本。

而对于 `MPA` 来说，更加注重于单个页面组件的之间的解耦，同时因为页面之间相互独立，那么使得 `MPA` 应用初始化成本小，但是页面重启的成本高。基于应用组件之间解耦的特性，`MPA` 更加适合开发大型复杂的 `web` 应用。在开发成本上来说，虽然代码复用性低于 `SPA`，但其解耦所带来的便捷拓展性，是 `SPA` 无法比拟的。`MPA` 无论是增加还是删除页面，对于其他的单页面组件影响都很小。但是，`SPA` 之间存在组件复用时，也就存在了代码耦合。特别是存在复杂逻辑的组件之间拓展功能时需要更加的小心翼翼。

虽然以上简要总结了 `SPA` 与 `MPA` 之间的差异，共同点以及各自的优化方式。但是在技术选型时，不仅需要考虑了以上因素，而且还需要结合特定的应用场景与自身的开发条件来选择合适的应用架构。`MPA` 与 `SPA` 没有说一定是要有对应的适用应用类型方式，因为应用场景，开发条件都是必须考虑进去的选型因素。
