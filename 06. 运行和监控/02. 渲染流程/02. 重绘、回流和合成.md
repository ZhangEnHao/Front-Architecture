## 重绘（Repaint）和回流（Reflow）

- 重绘是当节点需要更改外观而不会影响布局的绘制属性，比如改变 color 就叫称为重绘

对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了布局阶段）。

相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

- 回流是布局或者几何属性需要改变。

对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来，这个过程就是回流（也叫重排）。重排需要更新完整的渲染流水线，所以开销也是最大的。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。

重绘，重排是cpu运算的，且占用页面主线程。

1. 常见引起回流属性和方法

任何会改变元素几何信息 (元素的位置和尺寸大小) 的操作，都会触发回流，

- 页面渲染初始化；

- 添加或者删除 可见的 DOM 元素 / 样式；

- render 树变化，比如减少了 padding；

- 元素尺寸改变 —— 边距、填充、边框、宽度和高度；

- 内容变化，比如用户在 input 框中输入文字；

- 修改浏览器窗口尺寸时（即 resize 事件发生时，移动端没有这个问题），或是滚动的时候，**有可能**会触发（具体要看浏览器的规则）；

- 计算获取 offset(Top/Left/Width/Height)、scroll(Top/Left/Width/Height)、cilent(Top/Left/Width/Height)、width/height 和 调用了 getComputedStyle() 或者 IE 的 currentStyle 属性；

- 设置 style 属性的值；

- 改变 window 大小 / 字体 / 文字；

- 定位或者浮动

- 修改网页的默认字体时（这个很消耗性能）；

- display: none；

2. 常见引起重绘属性和方法

- color

- border-style

- visibility

- background

- outline

## 减少重绘和回流，避免布局抖动（layout thrashing）

如果页面经常需要做重绘和回流，就很容易导致“页面抖动”。所以要减少重绘和回流。

1. 使用 `transfrom:translate`让元素做位移

比如说，如果想改变一个元素的位置，很多人可能会使用相对布局的 left、top 属性，但是这个属性会引起回流。我们可以使用 `transfrom:translate` 让元素做位移，这个属性既不会触发回流，也不会触发 重绘，只会触发合成 conmposite。

2. 把 `DOM` 离线后修改

比如：先把 `DOM` 给 `display:none` (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来；

再比如说，vue、react 这样的框架，采用了虚拟 `DOM`，它会把涉及到 `DOM` 修改的操作积攒起来，然后统一计算，批量处理，最后应用到真正的 `DOM` 上。

3. 避免循环操作 `DOM`，创建一个 `documentFragment` 或 `div`，在它上面应用所有 `DOM` 操作，最后再把它添加到 `window.document`

4. 读写分离。建议先批量读，然后再批量做写操作。

不要把节点的属性值放在一个循环里当成循环里的变量。可以使用 [FastDom](https://github.com/wilsonpage/fastdom) 批量对 DOM 进行读写操作。

[FastDom](https://github.com/wilsonpage/fastdom) 是用于做防抖的一个比较流行的解决方案。

5. 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）。

6. 不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局。

7. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`。

8. 减少逐项更改样式，最好一次性更改 `style`，或者将样式定义为 `class` 并一次性更新。

9. 避免多次读取 `offset` 等属性。无法避免则将它们缓存到变量

10. 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。

## 合成 (Composite)

渲染步骤中就提到了合成 (Composite)概念。**如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，把这个过程叫做合成。**

![避开重排和重绘](../images/composite.png)

在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

### 普通图层和复合图层

一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响。可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层

首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）

其次，`absolute` 布局（`fixed` 也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。

然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源
（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）

可以简单理解下：GPU 中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒。

### 如何变成复合图层（硬件加速）

- 3D 变换：`translate3d`、`translateZ`

- `opacity` 属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）

- `will-chang` 属性（这个比较偏僻），一般配合 `opacity` 与 `translate` 使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）

- `<video>`、`<iframe>`、`<canvas>` 和 `<webgl>` 标签

### `absolute` 和硬件加速的区别

`absolute` 虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算 `absolute` 中信息改变时不会改变普通文档流中 `RenderTree`，但是，浏览器最终绘制时，是整个复合层绘制的，所以 `absolute` 中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，`absolute` 带来的绘制信息变化过大，资源消耗是非常严重的）

而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）。

### 复合图层的作用

一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡

### 硬件加速时请使用 `z-index`

使用硬件加速时，尽可能的使用 `z-index`，防止浏览器默认给后续的元素创建复合层渲染

具体的原理时这样的：

**webkit CSS3 中，如果这个元素添加了硬件加速，并且 `z-index` 层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且 `releative` 或 `absolute` 属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能**

简单点理解，其实可以认为是一个隐式合成的概念：如果 a 是一个复合图层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层，这点需要特别注意。

## 答疑

### 超过一屏，在滑动的过程中会不会触发重排，为什么？

现代浏览器做了优化，把滚动操作交给了合成线程来处理，也就是说滚动的内容会被当成一个单独的图层，发生滚动的事件的时候，图层直接由合成线程来生成，也就是说这种情况下没有占用主线程，所以通常情况下不会产生重排和重回操作，只是简单合成就可以了，这样效率是最高的！

为什么说“通常”呢？ 这是因为目前渲染流程还是很复杂的，在滚动页面时，有些情况下，如果合成线程搞不定的，那么还要交给主线程去处理，这时候就涉及到重拍了，不过技术是往前发展的，渲染流程会变得越来约简单高效！

### 渲染进程里的帧的概念是什么样子的呢？

可以拿放电影电影来解释，通常，电影的帧速是24，也就是说每秒切换24幅画面，其中的每幅画面就是一帧。

理解什么是帧后，我们在回过头看看我们的页面。由于目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果页面中有一个动画、或一个渐变效果、或者用户正在滚动页面，那么浏览器渲染动画的频率至少要和刷新频率保持一致，也就是每秒需要更新60次，这样我们就能计算出来生成每帧的预算只有（1/60）毫秒，也就是16毫秒多一点(1 秒/ 60 = 16.66 毫秒)。如果超过16毫秒，帧率将下降，并且会出现画面抖动现象，此现象通常被称为卡顿，会对用户体验产生负面影响。

所以，如果想要保证画面的流畅，就需要尽量降低每帧的渲染时间，所以局部更新流水线显得非常重要了，能大大减少处理每帧所消耗的时间。

