## 关于 IP

### 什么是 IP 地址？

在 Internet 上有千百万台主机，为了区分这些主机，人们给每台主机都分配了一个专门的地址，称为 IP 地址。通过 IP 地址就可以访问到每一台主机。IP 地址由 4 部分数字组成，每部分都不大于 256，各部分之间用小数点分开。例如"FastDNS"主机的 IP 地址就是"202.85.220.46"，在您的浏览器上打入这个 IP 地址，就可以访问到 FastDNS 主页。

### 什么是固定 IP 地址？

固定 IP 地址是长期固定分配给一台计算机使用的 IP 地址，一般是特殊的服务器才拥有固定 IP 地址。

### 什么是动态 IP 地址？

通过 Modem 和电话线上网等的机子不具备固定 IP 地址，而是由 ISP 动态分配暂时的一个 IP 地址。普通人一般不需要去了解动态 IP 地址，这些都是计算机系统自动完成的。

### 什么是公有的 IP 地址？

公有地址（Public address）由 Inter NIC（Internet Network Information Center 因特网信息中心）负责。这些 IP 给注册并向 Inter NIC 提出申请的组织机构。通过它直接访问因特网。

### 什么是私有的 IP 地址？

私有地址（Private address）属于非注册地址，专门为组织机构内部使用。以下表列出留用的内部寻址地址：

A 类 10.0.0.0 B 类 172.16.0.0--172.31.0.0 C 类 192.168.0.0--192.168.255.0

## TCP/IP 协议

HTTP 是一个"传输协议"，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。

TCP/IP 协议是目前网络世界“事实上”的标准通信协议。TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。

这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。

TCP/IP 就是 TCP 和 IP 两个协议在一起协同工作，有上下层次的关系。

TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，IP 负责将包发送至接受者，传输过程要经 IP 路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址，然后在它们到达的时候重新组合它们。

### IP 协议（Internet Protocol）

主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。

1. IP 协议是计算机之间用来相互识别通信的一种机制，每台计算机都有一个 IP.用来在 internet 上标识这台计算机。IP 负责在因特网上发送和接收数据包。通过 IP，消息（或者其他数据）被分割为小的独立包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。

2. 现在使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。

3. IP 协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只查关键的头数据）。为了提供消息检验功能，直接在 IP 协议上设计了传输控制协议 TCP。

### TCP 协议（Transmission Control Protocol）传输控制协议

TCP 协议位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的应用程序之间通信，是 HTTP 协议得以实现的基础。

“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。

当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信，占用两个计算机之间整个的通信线路。TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。

## TCP 的三次握手与四次分手

### 3 次握手

第一次握手：主机 A 发送位码为 syn ＝ 1,随机产生 seq number=x 的数据包到服务器，客户端进入 SYN_SEND 状态，等待服务器的确认；主机 B 由 SYN=1 知道，A 要求建立联机；

第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack number(主机 A 的 seq+1),syn=1,ack=1,随机产生 seq=y 的包,此时服务器进入 SYN_RECV 状态;

第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number(主机 B 的 seq+1),ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。客户端和服务器端都进入 ESTABLISHED 状

态，完成 TCP 三次握手。

TCP 位码,有 6 种标示:SYN(synchronous 建立联机) ACK(acknowledgement 确认) PSH(push 传送) FIN(finish 结束) RST(reset 重置) URG(urgent 紧急)

Sequence number(顺序号码) Acknowledge number(确认号码)

### 4 次挥手

第一次挥手：主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；

第二次挥手：主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我也没有数据要发送了，可以进行关闭连接了；

第三次挥手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 CLOSE_WAIT 状态；

第四次挥手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。

### 问题

1. 为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。

2. client 发送完最后一个 ack 之后，进入 time_wait 状态，但是他怎么知道 server 有没有收到这个 ack 呢？莫非 sever 也要等待一段时间，如果收到了这个 ack 就 close，如果没有收到就再发一个 fin 给 client？这么说 server 最后也有一个 time_wait 哦？求解答！

因为网络原因，主动关闭的一方发送的这个 ACK 包很可能延迟，从而触发被动连接一方重传 FIN 包。极端情况下，这一去一回，就是两倍的 MSL 时长。如果主动关闭的一方跳过 TIME_WAIT 直接进入 CLOSED，或者在 TIME_WAIT 停留的时长不足两倍的 MSL，那么当被动

关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：1.旧的 TCP 连接已经不存在了，系统此时只能返回 RST 包 2.新的 TCP 连接被建立起来了，延迟包可能干扰新的连接，这就是为什么 time_wait 需要等待 2MSL 时长的原因。

## TCP/IP 协议栈的工作方式

TCP/IP 协议栈是如何工作的呢？

你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。

假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容，比如 HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据。

你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头。

接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头。

之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包。

快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面。

这个比喻里省略了很多 TCP/IP 协议里的细节，比如建连、路由、数据切分与重组、错误检查等，但核心的数据传输过程是差不多的。

HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。

接收数据是则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。

但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。

![](../images/protocolStackWorks.png)

## 总结

1. TCP/IP 分为四层，核心是二层的 IP 和三层的 TCP，HTTP 在第四层；

2. OSI 分为七层，基本对应 TCP/IP，TCP 在第四层，HTTP 在第七层；

3. OSI 可以映射到 TCP/IP，但这期间一、五、六层消失了；

4. 日常交流的时候我们通常使用 OSI 模型，用四层、七层等术语；

5. HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。

有一个辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。

当然，“两个凡是”也不是绝对的，比如dpdk就把tcp协议栈都拿到了操作系统外实现，但大多数情况下传输层以下都由操作系统负责。
