## 哈希表介绍

1. 哈希表通常是基于数组进行实现的, 但是相对于数组, 哈希表有很多的优势:

- 哈希表可以提供非常快速的插入-删除-查找操作

- 无论多少数据, 插入和删除值需要接近常量的时间: 即 `O(1)` 的时间级. 实际上, 只需要几个机器指令即可

- 哈希表的速度比树还要快, 基本可以瞬间查找到想要的元素

- 哈希表相对于树来说编码要容易很多.

哈希表相对于数组的一些不足:

- 哈希表中的数据是没有顺序的, 所以不能以一种固定的方式(比如从小到大)来遍历其中的元素.

- 通常情况下, 哈希表中的 `key` 是不允许重复的, 不能放置相同的 `key`, 用于保存不同的元素.

哈希表的结构就是数组, 但是它神奇的地方在于对下标值的一种变换, 这种变换可以称之为哈希函数, 通过哈希函数可以获取到 `HashCode`。

## 认识哈希化

- 哈希化: 将大数字转化成数组范围内下标的过程, 就称之为哈希化.

- 哈希函数: 通常会将单词转成大数字, 大数字在进行哈希化的代码实现放在一个函数中, 该函数成为哈希函数.

- 哈希表: 最终将数据插入到的这个数组, 就称之为是一个哈希表

## 地址的冲突

1. 链地址法

链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据, 而是一个链条.

这个链条使用的数据结构常见的是数组或者链表.

比如是链表, 也就是每个数组单元中存储着一个链表. 一旦发现重复, 将重复的元素插入到链表的首端或者末端即可.

当查询时, 先根据哈希化后的下标值找到对应的位置, 再取出链表, 依次查询找寻找的数据.

`Java` 中，链表长度大于 `9` 时采用红黑树

数组还是链表呢?

- 数组或者链表在这里其实都可以, 效率上也差不多.

- 因为根据哈希化的 `index` 找出这个数组或者链表时, 通常就会使用线性查找, 这个时候数组和链表的效率是差不多的.

- 在某些实现中, 会将新插入的数据放在数组或者链表的最前面, 因为觉得新插入的数据用于取出的可能性更大.

- 这种情况最好采用链表, 因为数组在首位插入数据是需要所有其他项后移的, 链表就没有这样的问题.

- 具体看业务需求, 不见得新的数据就访问次数会更多

2. 开放地址法

开放地址法其实就是要寻找空白的位置来放置冲突的数据项.

没有空白位置时即开放因子大于 `0.75`，就会对哈希表进行扩容，扩容一倍

探索空白位置的方式有三种方法:

- 线性探测：线性的查找空白的单元

1. 插入

- 插入的数据项经过哈希化得到的 `index`, 但是在插入的时候, 发现该位置已经存在数据项

- 线性探测就是从 `index` 位置 `+1` 开始一点点查找合适的位置来放置插入的数据项

- 空的位置就是合适的位置, 插入的数据项就会放在该位置.

2. 查询

- 查询和插入的过程比较相似.

- 首先待查询数据经过哈希化得到 `index`, 比较 `index` 的位置结果和待查询数据是否相同, 相同那么就直接返回.

- 不相同就线性查找, 从 `index` 位置 `+1` 开始查找和待查询数据一样的.

- 特别注意: 如果待查询数据的位置之前没有插入, 不会将整个哈希表查询一遍来确定待查询数据存不存在。在查询过程有一个约定, 就是查询到空位置, 就停止. (因为查询到这里有空位置, 待查询数据之前不可能跳过空位置去其他的位置.)

3. 删除

删除操作和插入查询比较类似, 但是也有一个特别注意点

注意: 删除操作一个数据项时, 不可以将被删除位置下标的内容设置为 `null`, 因为将被删除位置下标的内容设置为 `null` 可能会影响之后查询等其他操作, 所以通常删除一个位置的数据项时, 可以将它进行特殊处理(比如设置为 -1 ).

当之后操作看到 `-1` 位置的数据项时, 就知道查询时要继续查询, 但是插入时这个位置可以放置数据

4. 线性探测的问题:

线性探测有一个比较严重的问题, 就是聚集. 什么是聚集呢?

比如在没有任何数据的时候, 插入的是 `22-23-24-25-26`, 那么意味着下标值: `2-3-4-5-6` 的位置都有元素. 这种一连串填充单元就叫做聚集.

聚集会影响哈希表的性能, 无论是插入/查询/删除都会影响.

比如插入一个 32, 会发现连续的单元都不允许放置数据, 并且在这个过程中需要探索多次.

- 二次探测

1. 二次探测在线性探测的基础上进行了优化:

- 二次探测主要优化的是探测时的步长

- 线性探测, 可以看成是步长为 `1` 的探测, 比如从下标值 `x` 开始, 那么线性测试就是 `x+1, x+2, x+3` 依次探测.

- 二次探测, 对步长做了优化, 比如从下标值 `x` 开始, `x+1², x+2², x+3²`.

- 这样就可以一次性探测比较长的距离, 比避免那些聚集带来的影响.

2. 二次探测的问题:

但是二次探测依然存在问题, 比如我们连续插入的是 `32-112-82-2-192`, 那么它们依次累加的时候步长的相同的.也就是这种情况下会造成步长不一的一种聚集. 还是会影响效率.

- 再哈希法

为了消除线性探测和二次探测中无论步长 `+1` 还是步长 `+平法` 中存在的问题, 还有一种最常用的解决方案: 再哈希法.

1. 再哈希法:

二次探测的算法产生的探测序列步长是固定的: `1, 4, 9, 16`, 依次类推.

现在需要一种方法: 产生一种依赖关键字的探测序列, 而不是每个关键字都一样.

那么, 不同的关键字即使映射到相同的数组下标, 也可以使用不同的探测序列.

再哈希法的做法就是: 把关键字用另外一个哈希函数, 再做一次哈希化, 用这次哈希化的结果作为步长.

对于指定的关键字, 步长在整个探测中是不变的, 不过不同的关键字使用不同的步长.

2. 第二次哈希化需要具备如下特点:

和第一个哈希函数不同. (不要再使用上一次的哈希函数了, 不然结果还是原来的位置)

不能输出为 `0` (否则, 将没有步长. 每次探测都是原地踏步, 算法就进入了死循环)

3. 计算机专家已经设计出一种工作很好的哈希函数:

`stepSize = constant - (key % constant)`

其中 `constant` 是质数, 且小于哈希表的容量.

## 哈希化效率

哈希表中执行插入和搜索操作可以达到 `O(1)` 的时间级，如果没有发生冲突，只需要使用一次哈希函数和数组的引用，就可以插入一个新数据项或找到一个已经存在的数据项。

如果发生冲突，存取时间就依赖后来的探测长度。一个单独的查找或插入时间与探测的长度成正比，这里还要加上哈希函数的常量时间。

平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度也越来越长。

随着填装因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重, 所以来对比一下他们的效率, 再决定选取的方案.

1. 装填因子

装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值

装填因子 = 总数据项 / 哈希表长度

开放地址法的装填因子最大是 `1`, 因为它必须寻找到空白的单元才能将元素放入.

链地址法的装填因子可以大于 `1`, 因为拉链法可以无限的延伸下去. (当然后面效率就变低了)

2. 开放地址法

- 线性探测

下面的等式显示了线性探测时，探测序列(P)和填装因子(L)的关系

对成功的查找: `P = (1+1/(1-L)) / 2`

对不成功的查找: `P=(1+1/(1-L)^2) / 2`

- 二次探测和再哈希

二次探测和再哈希法的性能相当。它们的性能比线性探测略好。

对成功的搜索，公式是: `-log2(1 - loadFactor) / loadFactor`

对于不成功的搜搜, 公式是: `1 / (1-loadFactor)`

3. 链地址法

假如哈希表包含 `arraySize` 个数据项, 每个数据项有一个链表, 在表中一共包含 `N` 个数据项.
那么, 平均起来每个链表有 `N / arraySize`个 数据项呢.其实就是装填因子.

成功可能只需要查找链表的一半即可: `1 + loadFactor/2`

不成功呢? 可能需要将整个链表查询完才知道不成功: `1 + loadFactor`.

4. 效率的结论

链地址法相对来说效率是好于开放地址法的

所以在真实开发中, 使用链地址法的情况较多, 因为它不会因为添加了某元素后性能急剧下降.

比如在Java的HashMap中使用的就是链地址法.

