## `===`全等判断规则

1. 如果「类型」不同，就不相等；

2. 如果其中至少有一个是 `NaN`，那么不相等。

3. 如果两个值都是「数值」，并且是同一个值，那么相等；（! 例外）

4. 如果两个值都是「字符串」，且每个位置的字符都一样，那么相等；

5. 如果两个值都是 `true`，或者都是 `false`，那么相等；

6. 如果两个值都是 `null`，或者都是 `undefined`，那么相等；

7. 如果两个值都是「对象」，且都引用自同一个对象或函数，那么相等。

**全等总结**

1. 不同类型的值，直接返回 `false`。

2. 同一类型的原始类型值

同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回`true`，值不同就返回 `false`。

❗️ 需要注意的是，**`NaN `与任何值都不相等（包括自身）**。

❗️ 另外，`+0 `等于 `-0`，即：`+0 === -0 // true `。

3. 同一类型的复合类型值

同一类型的复合类型的值（对象、数组、函数）比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象（ 是否为同一引用 ）。

4. `undefined `和 `null`

**`undefined `和 `null `与自身严格相等，但是两者不严格相等。**

## `== `相等判断规则

使用 `== `时，若两侧类型相同，进行 `=== `判断，否则会发生隐式转换，使用 `== `时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：

1. 如果一个是「字符串」，一个是「数值」，把字符串转换成数值后再进行比较；

2. `Boolean `和其他任何类型比较，`Boolean `首先被转换为 `Number `类型。如果任一值是 `true`，把它转换成 `1 `再比较；如果任一值是 `false`，把它转换成 `0 `再比较；

注意：`undefined、null`和 `Boolean `比较，虽然 `undefined、null `和 `false `都很容易被想象成假值，但是他们比较结果是 `false`，原因是 `false`首先被转换成 `0`。

3. `null == undefined`比较结果是 `true`，除此之外，`null、undefined`和其他任何结果的比较值都为 `false`。

4. `NaN `和其他任何类型比较永远返回 `false`(包括和他自己)。

5. 如果一个是「对象」，另一个是「数值」或「字符串」，通过把 对象转换成基础类型 后，再对两个基础类型的值再比较。

`javaScript
[] == ![] // true
// !的优先级高于==，![]首先会被转换为 false，然后根据上面第三点，false 转换成 Number 类型 0，左侧[]转换为 0，两侧比较相等。

[null] == false // true
[undefined] == false // true
// 根据数组的 ToPrimitive 规则，数组元素为 null 或 undefined 时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为 0。
`

任何其他组合，都「不相等」。

**相等总结**

1. 原始类型的值

对于原始类型的数据，都会转换成数值（`Number`）类型再进行比较。

2. 对象与原始类型值比较

进行 对象转换成基础类型 操作。

3. `undefined `和 `null`

`undefined `和 `null `与其他类型的值比较 `== `时，结果都为 `false`；

它们互相比较时结果为 `true`，因为都表示「无」，但两者不「严格相等」，因为本质上还是不一样的，一个是「未定义」，一个是「空」。

## Object.is(value1, value2)

`Object.is() `判断两个值是否相同。如果下列任何一项成立，则两个值相同：

1. 两个值都是 `undefined`

2. 两个值都是 `null`

3. 两个值都是 `true `或者都是 `false`

4. 两个值是由相同个数的字符按照相同的顺序组成的字符串

5. 两个值指向同一个对象

6. 两个值都是数字并且

- 都是正零 `+0`

- 都是负零 `-0`

- 都是 `NaN`

- 都是除零和 `NaN `外的其它同一个数字

这种相等性判断逻辑和传统的 `== `运算不同，== 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 `"" == false `等于 `true `的现象），但 `Object.is `不会做这种类型转换。

这与 `=== `运算符的判定方式也不一样。`=== `运算符（和 `== `运算符）将数字值 `-0 `和 `+0 `视为相等，并认为 `Number.NaN`不等于 `NaN`。

## 面试题

1. 如何让：`a == 1 && a == 2 && a == 3`。

`javaScript const a = { value:[3,2,1], valueOf: function () {return this.value.pop(); }, } `

[JavaScript专题之如何判断两个对象相等](https://github.com/mqyqingfeng/Blog/issues/41)

[精读《如何比较 Object 对象》](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/157.%20%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%20Object%20%E5%AF%B9%E8%B1%A1%E3%80%8B.md)
