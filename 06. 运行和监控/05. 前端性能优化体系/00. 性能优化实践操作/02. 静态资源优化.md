## 图片优化 —— 质量与性能的博弈

[谈谈Web应用中的图片优化技巧及反思](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247484486&idx=1&sn=2da36c82ef04a1a6ed8aad23a558a484&chksm=fa2be4afcd5c6db99eaa20135de62588bc8e8fe96252f6a60e03465e78a483409f742341d656&scene=126&&sessionid=1664420293#rd)

《高性能网站建设指南》的作者 Steve Souders 曾在 2013 年的一篇 博客 中提到：

> 我的大部分性能优化工作都集中在 JavaScript 和 CSS 上，从早期的 Move Scripts to the Bottom 和 Put Stylesheets at the Top 规则。为了强调这些规则的重要性，我甚至说过，“JS 和 CSS 是页面上最重要的部分”。

> 几个月后，我意识到这是错误的。图片才是页面上最重要的部分。

> 我关注 JS 和 CSS 的重点也是如何能够更快地下载图片。图片是用户可以直观看到的。他们并不会关注 JS 和 CSS。确实，JS 和 CSS 会影响图片内容的展示，尤其是会影响图片的展示方式（比如图片轮播，CSS 背景图和媒体查询）。但是我认为 JS 和 CSS 只是展示图片的方式。在页面加载的过程中，应当先让图片和文字先展示，而不是试图保证 JS 和 CSS 更快下载完成。

这段话可谓字字珠玑。此外，雅虎军规和 Google 官方的最佳实践也都将图片优化列为前端性能优化必不可少的环节——图片优化的优先级可见一斑。

就图片这块来说，与其说我们是在做“优化”，不如说我们是在做“权衡”。因为我们要做的事情，就是去压缩图片的体积（或者一开始就选取体积较小的图片格式）。但这个优化操作，是以牺牲一部分成像质量为代价的。因此我们的主要任务，是尽可能地去寻求一个质量与性能之间的平衡点。

### 不同业务场景下的图片方案选型

#### 前置知识：二进制位数与色彩的关系

在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。

一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。

#### JPEG/JPG 格式

关键字：**有损压缩、体积小、加载快、不支持透明**

**JPG**

JPG 最大的特点是有损压缩。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG 的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求，这一点决定了它压缩前后的质量损耗并不容易被我们人类的肉眼所察觉——前提是你用对了业务场景。

JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。

使用 JPG 呈现大图，既可以保住图片的质量，又不会带来令人头疼的图片体积，是当下比较推崇的一种方案。

JPG 的缺陷：有损压缩在上文所展示的轮播图上确实很难露出马脚，但当它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。

**JPEG**

JPEG（Joint Photographic Experts Group）是一种针对彩色照片而广泛使用的有损压缩图形格式，属于位图。

常用文件扩展名为`.jpg`，也有 `.jpeg`和`.jpe`。JPEG 在互联网上常被应用于存储和传输照片。

- 适合：颜色丰富的照片、彩色图大焦点图、通栏 banner 图；结构不规则的图形。

- 不适合：线条图形和文字、图标图形，因为它的压缩算法不太这些类型的图形；此外，JPEG 图像不支持透明度处理，透明图片需要召唤 PNG 来呈现。

#### PNG-8 与 PNG-24

关键字：**无损压缩、质量高、体积大、支持透明**

PNG（Portable Network Graphics）是一种无损压缩的位图图形格式，支持索引、灰度、RGB 三种颜色方案以及 Alpha 通道等特性。

PNG 最初是作为替代 GIF 来设计的，能够显示 256 色，文件比 JPEG 或者 GIF 大，但是 PNG 非常好的保留了图像质量。支持 Alpha 通道的半透明和透明特性。最高支持 24 位彩色图像（PNG-24）和 8 位灰度图像（PNG-8）。

PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是体积太大。

**PNG-8 与 PNG-24 的选择题**

理论上来说，当你追求最佳的显示效果、并且不在意文件体积大小时，是推荐使用 PNG-24 的。

但实践当中，为了规避体积的问题，我们一般不用 PNG 去处理较复杂的图像。当我们遇到适合 PNG 的场景时，也会优先选择更为小巧的 PNG-8。

如何确定一张图片是该用 PNG-8 还是 PNG-24 去呈现呢？好的做法是把图片先按照这两种格式分别输出，看 PNG-8 输出的结果是否会带来肉眼可见的质量损耗，并且确认这种损耗是否在我们（尤其是你的 UI 设计师）可接受的范围内，基于对比的结果去做判断。

**应用场景**

复杂的、色彩层次丰富的图片，用 PNG 来处理的话，成本会比较高，我们一般会交给 JPG 去存储。

考虑到 PNG 在处理线条和颜色对比度方面的优势，我们主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等。

- 适合：颜色简单、对比度较强的透明小图在 PNG 格式下有着良好的表现。

- 适合：由于是无损存储，所以不太适合体积太大的彩色图像。

比如说，如果你需要带透明背景的图片，此时就可以用 png 格式的图。

#### GIF 格式

GIF（Graphics Interchange Format）是一种位图图形格式，以 8 位色（即 256 种颜色）重现真彩色的图像，采用 LZW 压缩算法进行编码。

支持 256 色；仅支持完全透明和完全不透明；如果需要带动画效果的图片，GIF 是比较通用的选择。

- 适合：动画，图标。

- 不适合：每个像素只有 8 比特，不适合存储彩色图片。

#### SVG

关键字：**文本文件、体积小、不失真、兼容性好**

SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。

SVG 和性能关系最密切的一点就是：SVG 与 PNG 和 JPG 相比，**文件体积更小，可压缩性更强。**

当然，作为矢量图，它最显著的优势还是在于**图片可无限放大而不失真**这一点上。这使得 SVG 即使是被放到视网膜屏幕上，也可以一如既往地展现出较好的成像品质——1 张 SVG 足以适配 n 种分辨率。

此外，**SVG 是文本文件**。我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。这使得 SVG 文件可以被非常多的工具读取和修改，具有**较强的灵活性**。

SVG 的局限性主要有两个方面，一方面是它的渲染成本比较高，这点对性能来说是很不利的。另一方面，SVG 存在着其它图片格式所没有的学习成本（它是可编程的）。

**SVG 的使用方式与应用场景**

SVG 是文本文件，我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。

在实际开发中，我们更多用到的是后者。很多情况下设计师会给到我们 SVG 文件，就算没有设计师，我们还有非常好用的[在线矢量图形库](http://www.iconfont.cn/)。对于矢量图，我们无须深究过多，只需要对其核心特性有所掌握、日后在应用时做到有迹可循即可。

#### Base64

关键字：**文本文件、依赖编码、小图标解决方案**

Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。在了解 Base64 之前，我们先来了解一下雪碧图。

**前置知识：最经典的小图标解决方案——雪碧图（CSS Sprites）**

雪碧图、CSS 精灵、CSS Sprites、图像精灵，说的都是这个东西 —— 一种将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中的每一部分的技术。

> 图像精灵（sprite，意为精灵），被运用于众多使用大量小图标的网页应用之上。它可取图像的一部分来使用，使得使用一个图像文件替代多个小文件成为可能。相较于一个小图标一个图像文件，单独一张图片所需的 HTTP 请求更少，对内存和带宽更加友好。 —— MDN

和雪碧图一样，Base64 图片的出现，也是为了减少加载网页图片时对服务器的请求次数，从而提升网页性能。**Base64 是作为雪碧图的补充而存在的。**

**理解 Base64**

Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。

**Base64 的应用场景**

Base64 对应的图片往往是非常小的 Logo。

既然 Base64 这么棒，我们何不把大图也换成 Base64 呢？

这是因为，Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的）。如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失。

在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。

因此，Base64 并非万全之策，我们往往在一张图片满足以下条件时会对它应用 Base64 编码：

- 图片的实际尺寸很小（大家可以观察一下掘金页面的 Base64 图，几乎没有超过 2kb 的）

- 图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）

- 图片的更新频率非常低（不需我们重复编码和修改文件内容，维护成本较低）

**Base64 编码工具推荐**

这里最推荐的是利用 webpack 来进行 Base64 的编码 —— webpack 的 `url-loader` 非常聪明，它除了具备基本的 Base64 转码能力，还可以结合文件大小，帮我们判断图片是否有必要进行 Base64 编码。

除此之外，市面上免费的 Base64 编解码工具种类是非常多样化的，有很多网站都提供在线编解码的服务，大家选取自己认为顺手的工具就好。

#### Webp 格式

关键字：**年轻的全能型选手**

Webp 是一种现代图像格式，可为图像提供无损压缩和有损压缩，这使得它非常灵活。由 Google 在购买 On2 Technologies 后发展出来专为 Web 开发的一种**旨在加快图片加载速度的图片格式**，以 BSD 授权条款发布。

**WebP 的优点**

WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。

WebP 的官方介绍对这一点有着更权威的阐述：

> 与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。

> 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。

图片优化是质量与性能的博弈，从这个角度看，WebP 无疑是真正的赢家。

**WebP 的局限性**

WebP 纵有千般好，但它毕竟太年轻。我们知道，任何新生事物，都逃不开兼容性的大坑。此外，WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。

**WebP 的应用场景**

Webp 的优秀算法能同时保证图像质量和较小体积；可以插入多帧，实现动画效果；可以设置透明度；采用 8 位压缩算法。

无损的 Webp 比 PNG 小 26%，有损的 Webp 比 JPEG 小 25-34％，比 GIF 有更好的动画。

现在限制我们使用 WebP 的最大问题不是“这个图片是否适合用 WebP 呈现”的问题，而是“浏览器是否允许 WebP”的问题，即我们上文谈到的兼容性问题。具体来说，一旦我们选择了 WebP，就要考虑在 Safari 等浏览器下它无法显示的问题，也就是说我们需要准备 PlanB，准备降级方案。

目前真正把 WebP 格式落地到网页中的网站并不是很多，这其中淘宝首页对 WebP 兼容性问题的处理方式就非常有趣。

可以打开 Chrome 的开发者工具搜索其源码里的 WebP 关键字，注意一下 WebP 图片的链接地址：.webp 前面，还跟了一个 .jpg 后缀！

现在先大胆地猜测，这个图片应该至少存在 jpg 和 webp 两种格式，程序会根据浏览器的型号、以及该型号是否支持 WebP 这些信息来决定当前浏览器显示的是 .webp 后缀还是 .jpg 后缀。带着这个预判，我们打开并不支持 WebP 格式的 Safari 来进入同样的页面，再次搜索 WebP 关键字：

Safari 提示找不到，这也是情理之中。定位到刚刚示例的 WebP 图片所在的元素，查看一下它在 Safari 里的图片链接：

看到同样的一张图片，在 Safari 中的后缀从 .webp 变成了 .jpg！看来果然如此——站点确实是先进行了兼容性的预判，在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式（本质是对图片的链接地址作简单的字符串切割）。

此外，还有另一个维护性更强、更加灵活的方案——把判断工作交给后端，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。

由此也可以看出，我们 WebP 格式的局限性确实比较明显，如果决定使用 WebP，兼容性处理是必不可少的。

### 总结

- banner 图、大图，可以用 jpg、webp 格式。

- 图标、带透明背景的图，可以用 png 格式。

- 带动画效果的图，可以用 gif 格式。

## 图片优化的常见方法

### 1. 用工具压缩图片

**压缩 PNG 图片**：

- 工具：[node-pngquant-native](https://www.npmjs.com/package/node-pngquant-native)

- 介绍：跨平台、压缩比特别高，压缩 png24 非常好。

安装方法：

```
npm install node-pngquant-native
```

**压缩 JPEG 图片**：

- 工具：[jpegtran](https://www.npmjs.com/package/jpegtran)

- 官网：<https://www.npmjs.com/package/jpegtran>

- 介绍：跨平台，但压缩的比率只有 80-90%。

安装方法：

```bash
npm install –g jpegtran
```

使用方法：

```bash
jpegtran -copy none -optimize -outfile output_file.jpg input_file.jpg
```

**压缩 GIF 图**：

- 工具：Gifsicle

- 官网（含安装方法）：<https://www.lcdf.org/gifsicle/>

- 介绍：Gifsicle 通过改变每帧比例，减小 gif 文件大小，同时可以使用透明来达到更小的文件大小，是目前公认的最好的解决方案。

使用方法：

```bash
# 压缩命令。注意，这里是将压缩级别设置为3。如果将压缩级别设置为1或者2，则基本不压缩。
gifsicle --optimize=3 -o out_file.gif in_file.gif

# 裁掉透明部分
gifsicle --optimize=3 --crop-transparency -o out_file.gif in_file.gif
```

### 2. 将图片尺寸跟随网络环境进行变化

**具体方案**：不同网络环境（Wifi/4G/3G）下，加载不同尺寸和像素的图片，通过在图片 URL 中添加参数来改变。

图片 url 举例 1：（图片的原始 url 链接）

```
https://img12.360buyimg.com/img/s3866x3866_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg
```

图片 url 举例 2：（通过图片的 url 参数，将这张图的尺寸设置为 200px）

```
https://img12.360buyimg.com/img/s200x200_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg
```

### 3. 响应式图片

**方法 1**：通过 JavaScript 绑定事件，检测窗口大小，以此设置图片大小。

**方法 2**：CSS 媒体查询。

代码举例：（在 640px 的窗口大小里，设置图片的尺寸为 640px）

```css
@media screen and (max-width: 640px) {
  my_image {
    width: 640px;
  }
}
```

**方法 3**：img 标签的 `srcset` 属性。这个是 H5 的新特性。

代码举例：

```html
<img
  srcset="img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x"
  src="“img-960w.jpg”"
  alt="“img”"
/>
（x 描述符：表示图像的设备像素）
```

**方法 4**: picture

### 4. 逐步加载图像：lazyload、LQIP、LQIP

**方法 1**、使用统一占位符。俗称图片的`懒加载（lazyload）`。

**方法 2**、使用 **LQIP** 的图片加载方式。也就是说，在大图没有完全加载出来的情况下，先这张图对应的的低质量图片进行占位。

LQIP（Low Quality Image Placeholders）：低质量图像占位符。这种技术背后的想法是，在网络环境较差的情况下，你可以尽快向用户展示完全可用的网页，为他们提供更好的体验。即使在更好的网络连接上，这仍然为用户提供了更快的可用页面，并且改善了体验。

- 安装 LQIP 工具：`npm install lqip`

- GitHub 源码：https://github.com/zouhir/lqip-loader

代码举例：（将目标图片转换为 LQIP 形式的图）

```js
const lqip = require("lqip");

//文件路径
const file = "./in.png";

//将输入的图片转为base64
lqip.base64(file).then((res) => {
  // 色值
  console.log(res);
});

lqip.palette(file).then((res) => {
  //这里输出的是base64的图片地址
  console.log(res);
});
```

另外，我们还可以使用 **SQIP** 的图片加载方式。

SQIP（SVG Quality Image Placeholders）： SVG 格式的图像占位符。

- 安装 SQIP 工具：`npm install sqip`

- GitHub 源码：<https://github.com/axe312ger/sqip>

代码举例：（将目标图片转换为 SQIP 形式的图）

```js
const sqip = require("sqip");

const result = sqip({
  filename: "./input_file.png",
  numberOfPrimitives: 10, //可根据不同应用场景设置大小
});

console.log(result.final_svg);
```

**方法 3**

[react-lazy-load-image-component]()
[verlok/lazyload]()
[yall.js]()
[Blaz]()

### 渐进式图片

### 5. 雪碧图（Image spriting）

雪碧图是比较常见的图片优化方式，也就是把多张小图合并成一张大图。这样的话，就只需做一次网络请求，减少图片的 http 请求次数。

读者们可以自行查阅。

### 6. 有些场景下，并不需要图片文件

有些场景下，并不需要图片，我们可以用其他的方式来代替图片。

举例：

- Web Font 代替图片

- 使用 Data URI 代替图片。base64 就是属于 Data URI 的方式。

### 7. 在服务器端进行图片自动优化

图片服务器自动化优化是可以在图片 URL 链接上增加不同特殊参数，服务器自动化生成。通过这些参数，可以设置图片的不同格式、大小、质量。

**常见处理方式**：

- 图片裁剪：按长边、短边、填充、拉伸等缩放。

- 图片格式转换：支持 JPG，GIF，PNG，WebP 等，支持不同的图片压缩率。

- 图片处理：添加图片水印、高斯模糊、重心处理、裁剪边框等。

- AI 能力：鉴黄、涉政、智能抠图、智能排版、智能配色、智能合成等 AI 功能。

**图片举例**：

比如 JD 公司的图片链接，就会在服务器端做优化处理。通过修改图片链接中的参数，就能自动达到相应的优化效果。

原始图片链接：

```
https://img12.360buyimg.com/img/s3866x3866_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg
```

将图片压缩为 200\*150：

```
https://img12.360buyimg.com/img/s200x200_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg
```

将图片转换为 webp 格式：

```
https://img12.360buyimg.com/img/s200x200_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.webp
```

将图片质量压缩至 10%：

```
https://img12.360buyimg.com/img/s3866x3866_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg.q10
```

## 字体优化

font-display

## HTML 优化

### 1. 精简 HTML 代码

- 减少 HTML 的嵌套。

- 减少 DOM 节点数。

- 减少无语义代码（比如: <div class=“clear”></div> 消除浮动，其实可以用 css 来处理）。

- 删除 http 或者 https：如果 URL 的协议头和当前页面的协议头一致的，或者此 URL 在多个协议头都是可用的，则可以考虑删除协议头。

- 删除多余的空格、换行符、缩进和不必要的注释。

- 省略冗余标签和属性。

- 使用相对路径的 URL。

### 2. 文件放在合适位置

- CSS 样式文件链接尽量放在页面头部。

CSS 加载不会阻塞 DOM tree 解析，但是会阻塞 DOM Tree 渲染，也会阻塞后面 JS 执行。

任何 body 元素之前，可以确保在文档部分中解析了所有 CSS 样式（内联和外联），从而减少了浏览器必须重排文档的次数。

如果放置页面底部，就要等待最后一个 CSS 文件下载完成，此时会出现"白屏"，影响用户体验。

- JS 引用放在 HTML 底部

防止 JS 在加载、解析、执行时，阻塞了页面后续元素的正常渲染。

- `<script>` 标签加上 defer 属性 和 async 属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。defer 属性用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。async 属性： HTML5 新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。

### 3. 增强用户体验

- 设置 favicon.ico

网站如果不设置 favicon.ico，控制台会报错。另外页面加载过程中如果没有图标，则会出现 loading 过程，也不利于记忆网站品牌，建议统一添加。

- 增加首屏必要的 CSS 和 JS

页面如果需要等待所的依赖的 JS 和 CSS 加载完成才显示，则在渲染过程中页面会一直显示空白，影响用户体验，建议在首屏增加必要的 CSS 和 JS，比如页面框架背景图片或者 loading 图标，内联在 HTML 页面中。这样做，首屏能快速显示出来，缓解用户焦虑。现在很多网页在初始化的时候，流行做**骨架屏**，小伙伴们也可以研究下。

## CSS 优化

### 1. 提升 CSS 渲染性能

- 谨慎使用 expensive 属性，这类属性比较耗浏览器的性能。比如：`nth-child` 伪类；`position: fixed` 定位。

- 尽量减少样式的层级数。

比如：`div ul li span i {color: blue;}`这样的层级就太深了。建议给 i 标签设置 class 属性，然后通过 class 直接设置样式属性，可以提升浏览器的查询效率。

- 尽量避免使用占用过多 CPU 和内存的属性。比如：`text-indnt:-99999px`。

- 尽量少使用耗电量大的属性。比如：CSS3 3D transforms、CSS3 transitions、Opacity 这样的属性会消耗 GPU。

- <link> 标签的 rel 属性 中的属性值设置为 preload 能够让你在你的 HTML 页面中可以指明哪些资源是在页面加载完成后即刻需要的，最优的配置加载顺序，提高渲染性能。

### 2. 合适使用 CSS 选择器

- 尽量避免使用 CSS 表达式。

比如 `background-color: expression( (new Date()).getHours()%2 ? "#FFF" : "#000" );`这个属性的意思是，每间隔两小时，改变白景色。

- 尽量避免使用通配选择器。

比如 `body > a {font-weight:blod;}`这样的属性，可能会把 body 里所有的标签遍历一遍，才找到 a 标签，比较耗时。

- 尽量避免类正则的属性选择器：`*=， |=， ^=， $=`

### 3. 提升 CSS 文件加载性能

- 使用外链的 CSS。

我们知道，内联的 css 是在 html 内部写的。相比之下，外链的 CSS 文件是放在 CDN 上的，可以缓存，既能减少 html 页面的体积大小，也能利用缓存减少资源的请求。

- 尽量避免使用 @import 方法

整个 CSS 加载完成后，浏览器会把 import 中所有依赖的文件全部加载完成后，浏览器才会接着往下渲染。这个过程会阻塞 CSS 文件的加载过程。

### 4. 精简 CSS 代码

- 使用缩写语句

- 删除不必要的零。比如 0.2 可以写成 .2

- 删除不必要的单位，比如 0px 可以写成 0

- 删除过多的分号、空格和注释，言简意赅

- 尽量减少样式表的大小

当然，很多地方可以在编译时，通过压缩工具来处理；但是我们在写代码时，也应该有良好的编码习惯。

### 5. 合理使用 Web Fonts

- 将字体文件部署在 CDN 上。

- 或者将字体以 base64 形式保存在 CSS 中并通过 localStorage 进行缓存

- Google 字体库因为某些不可抗拒原因，应该使用国内托管服务

### 6. CSS 动画优化

- 尽量避免同时出现过多动画。

- 延迟动画初始化：让其他的重要的 CSS 样式优先渲染。

- 结合 SVG。

## JavaScript 总体优化

优化原则：

- 当需要的时候才优化

- 考虑可维护性

### 1. 提升 JavaScript 文件加载性能

加载元素的顺序 CSS 文件放在 <head> 里， JavaScript 文件放在 <body> 里。

### 2. JavaScript 变量和函数优化

- 尽量使用 id 选择器

- 尽量避免使用 eval

- JavaScript 函数尽可能保持简洁

- 使用事件节流函数

- 使用事件委托

### 3. JavaScript 动画优化

- 避免添加大量 JavaScript 动画

- 尽量使用 CSS3 动画

- 尽量使用 Canvas 动画

- 合理使用 requestAnimationFrame 动画代替 setTimeout、setInterval

- requestAnimationFrame 可以在正确的时间进行渲染，setTimeout（callback）和 setInterval（callback）无法保证 callback 回调函数的执行时机。

### 4. 合理使用缓存

- 合理缓存 DOM 对象

- 缓存列表长度

- 使用可缓存的 Ajax

## JavaScript 缓存优化

### 1. Cookie

通常由浏览器存储，然后将 Cookie 与每个后续请求一起发送到同一服务器。收到 HTTP 请求时，服务器可以发送带有 Cookie 的 header 头。可以给 Cookie 设置有效时间。

应用：

- 会话管理：登录名，购物车商品，游戏得分或服务器应要记录的其他任何内容

- 个性化：用户首选项，主题或其他设置

- 跟踪：记录和分析用户行为，比如埋点 visitkey

### 2. sessionStorage

创建一个本地存储的键/值对。

应用：

- 缓存。

- 页面应用页面之间传值。

### 3. LocalStorage

本地存储。

应用于：

- 缓存静态文件内容 JavaScript /CSS（比如百度 M 站首页）

- 缓存不常变更的 API 接口数据

- 储存地理位置信息

- 浏览在页面的具体位置

### 4. IndexedDB

索引数据库。

应用：

- 客户端存储大量结构化数据

- 没有网络连接的情况下使用（比如 Google Doc、石墨文档）

- 将冗余、很少修改、但经常访问的数据，以避免随时从服务器获取数据

## 关键渲染路径优化

为了尽快完成页面的「首次渲染」，需要尽可能减少以下三种因素：

- 关键资源的数量

关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。

- 关键路径长度

关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。

- 关键字节的大小

浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。

优化步骤:

1. 对关键路径进行「分析」和特性描述：资源数、字节数、长度。

2. 最大限度「减少关键资源的数量」：删除它们，延迟它们的下载，将它们标记为异步等。

3. 优化「关键字节数」以缩短下载时间（往返次数）。

4. 优化其余关键资源的「加载顺序」：您需要尽早下载所有关键资产，以缩短关键路径长度。

## JavaScript 模块化加载方案和选型

- CommonJS

旨在 Web 浏览器之外为 JavaScript 建立模块生态系统。Node.js 模块化方案受 CommonJS。

- AMD (Asynchronous Module Definition)（异步模块定义）规范。

RequireJS 模块化加载器：基于 AMD API 实现。

- CMD（ Common Module Definition）（通用模块定义）规范。

SeaJS 模块化加载器：遵循 CMD API 编写。

- ES6 import。

## 减少回流和重绘重要举措

### CSS

- 避免过多样式嵌套

- 避免使用 CSS 表达式

- 使用绝对定位，可以让动画元素脱离文档流

- 避免使用 table 布局

- 尽量不使用 float 布局

- 图片最好设置好 width 和 height

- 尽量简化浏览器不必要的任务，减少页面重新布局

- 使用 Viewport 设置屏幕缩放级别

- 避免频繁设置样式，最好把新 style 属性设置完成后，进行一次性更改

- 避免使用引起回流/重绘的属性，最好把相应变量缓存起来

### JavaScript

- 最小化回流和重排：为了减少回流发生次数，避免频繁或操作 DOM，可以合并多次对 DOM 修改，然后一次性批量处理。

- 控制绘制过程和绘制区域：绘制过程开销比较大的属性设置应该尽量避免减少使用；同时，减少绘制区域范围。

- 防抖和节流

## DOM 编程优化的⽅式方法

### 控制 DOM 大小

众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量 DOM 元素。想象一下，从一个上万节点的 DOM 树上，使用 querySelectorAll 或 getElementByTagName 方法查找某一个节点，是非常耗时的。另外元素绑定事件，事件冒泡和事件捕获的执行也会相对耗时。

通常控制 DOM 大小的技巧包括：

- 合理的业务逻辑

- 延迟加载即将呈现的内容

### 简化 DOM 操作

对 DOM 节点的操作统一处理后，再统一插入到 DOM Tree 中。

可以使用 fragment，尽量不在页面 DOM Tree 里直接操作。

现在流行的框架 Angular、React、Vue 都在使用虚拟 DOM 技术，通过 diff 算法简化和减少 DOM 操作。

## 静态文件压缩工具介绍

HTML 压缩工具：

- html-minifier：https://www.npmjs.com/package/html-minifier

CSS 压缩工具：

- clean-css：https://www.npmjs.com/package/clean-css

JavaScript 压缩工具：

- uglify-js：https://www.npmjs.com/package/uglify-js

- 使用方法：uglifyjs in.js -o out.js

## 静态⽂文件打包⽅方案

- 公共组件拆分

- 压缩： JavaScript /CSS/图片

- 合并： JavaScript /CSS 文件合并，CSS Sprite

- Combo： JavaScript /CSS 文件

## 静态⽂文件版本号更新策略

缓存更新：CDN 或 ng 后台刷新文件路径，更新文件 header 头。

文件 name.v1-v100.js：

- 大功能迭代每次新增一个大版本，比如由 v1 到 v2

- 小功能迭代新增加 0.0.1 或者 0.1.0，比如从 v1.0.0 至 v1.0.1

- 年末 ng 统一配置所有版本 302 至最新版

- 时间戳.文件 name.js：以每次上线时间点做差异。

- hash.文件。以文件内容 hash 值做 key。

## 前端构建工具介绍和选型建议

### 常用构建工具

- Gulp：通过流（Stream）来简化多个任务间的配置和输出，配置代码相对较少。

- Webpack：预编译，中间文件在内存中处理，支持多种模块化，配置相对很简单。

- FIS

### webpack 打包优化

- 定位体积大的模块

- 删除没有使用的依赖

- 生产模式进行公共依赖包抽离

- 开发模式进行 DLL & DllReference 方式优化

[谈谈 Web 应用中的图片优化技巧及反思](https://segmentfault.com/a/1190000020047949)
