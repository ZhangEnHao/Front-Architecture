## TCP 的位置

TCP 工作在网络 OSI 的七层模型中的第四层——Transport 层，IP 在第三层——Network 层，ARP 在第二层——Data Link 层；

在第二层上的数据，我们把它叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。

数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。 在 OSI 七层模型中，每一层的作用和对应的协议如下：

| OSI 中的层 |                 功能                 |           TCP/IP 协议族            |
| :--------: | :----------------------------------: | :--------------------------------: |
|   应用层   | 文件传输,电子邮件,文件服务,虚拟终端  | TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telnet |
|   表示层   |     数据格式化,代码转换,数据加密     |              没有协议              |
|   会话层   |      解除或建立与别的接点的联系      |              没有协议              |
|   传输层   |           提供端对端的接口           |              TCP,UDP               |
|   网络层   |           为数据包选择路由           |     IP,ICMP,RIP,OSPF,BGP,IGMP      |
| 数据链路层 |    传输有地址的帧以及错误检查功能    |    SLIP,CSLIP,PPP,ARP,RARP,MTU     |
|   物理层   | 以二进制数据格式在物理媒体上传输数据 |     ISO2110,IEEE802,IEEE802.2      |

## 3 次握手

第一次握手：主机 A 发送位码为 syn ＝ 1,随机产生 seq number=x 的数据包到服务器，客户端进入 SYN_SEND 状态，等待服务器的确认；主机 B 由 SYN=1 知道，A 要求建立联机；

第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack number(主机 A 的 seq+1),syn=1,ack=1,随机产生 seq=y 的包,此时服务器进入 SYN_RECV 状态;

第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number(主机 B 的 seq+1),ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。客户端和服务器端都进入 ESTABLISHED 状

态，完成 TCP 三次握手。

TCP 位码,有 6 种标示:SYN(synchronous 建立联机) ACK(acknowledgement 确认) PSH(push 传送) FIN(finish 结束) RST(reset 重置) URG(urgent 紧急)

Sequence number(顺序号码) Acknowledge number(确认号码)

## 4 次挥手

第一次挥手：主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；

第二次挥手：主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我也没有数据要发送了，可以进行关闭连接了；

第三次挥手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 CLOSE_WAIT 状态；

第四次挥手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。

## 问题

1.为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。

2.client 发送完最后一个 ack 之后，进入 time_wait 状态，但是他怎么知道 server 有没有收到这个 ack 呢？莫非 sever 也要等待一段时间，如果收到了这个 ack 就 close，如果没有收到就再发一个 fin 给 client？这么说 server 最后也有一个 time_wait 哦？求解答！

因为网络原因，主动关闭的一方发送的这个 ACK 包很可能延迟，从而触发被动连接一方重传 FIN 包。极端情况下，这一去一回，就是两倍的 MSL 时长。如果主动关闭的一方跳过 TIME_WAIT 直接进入 CLOSED，或者在 TIME_WAIT 停留的时长不足两倍的 MSL，那么当被动

关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：1.旧的 TCP 连接已经不存在了，系统此时只能返回 RST 包 2.新的 TCP 连接被建立起来了，延迟包可能干扰新的连接，这就是为什么 time_wait 需要等待 2MSL 时长的原因。

收集整理自：（果冻想还有 TCP 首部，TCP Flags，3 次握手 4 次分手原因详细解释，必看必看）

[果冻想](http://www.jellythink.com/archives/705#prettyPhoto)

[四月天](http://www.cnblogs.com/rootq/articles/1377355.html)
