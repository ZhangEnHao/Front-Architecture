## 前言

浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是 JS 引擎。渲染引擎在不同的浏览器中也不是都相同的。目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的可能就是 Webkit 内核了，Webkit 内核是当下浏览器世界真正的霸主。

本文我们就以 Webkit 为例，对现代浏览器的渲染过程进行一个深度的剖析。

从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：
  - DNS 查询
  - TCP 连接
  - HTTP 请求即响应
  - 服务器响应
  - 客户端渲染

## 页面加载过程(客户端渲染)

- 浏览器根据 DNS 服务器得到域名的 IP 地址；
- 向这个 IP 的机器发送 HTTP 请求；
- 服务器收到、处理并返回 HTTP 请求；
- 浏览器得到返回内容。(HTML)

## 浏览器渲染过程

浏览器渲染过程大体分为如下几部分：

1. 处理 HTML(HTML/SVG/XHTML) 并构建 DOM 树(DOM Tree)。

2. 处理 CSS 构建 CSSOM 树(CSS Rule Tree)。

3. 遇到 <script> 则暂停渲染，优化加载并执行 JS 代码， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。

4. 将 DOM 树与 CSSOM 树合并成一个渲染树(Rendering Tree)。
   - Rendering Tree 渲染树并不等同于 DOM 树，渲染树只会包括需要显示的节点和这些节点的样式信息。如果某个节点是 display: none 的，那么就不会在渲染树中显示。
   - CSS 的 Rule Tree 主要是为了完成匹配并把 CSS Rule 附加上 Rendering Tree 上的每个 Element（也就是每个 Frame）。

5. 根据渲染树来布局，计算每个节点(Frame)的位置(layout 和 reflow 过程)。

6. 调用 GPU 绘制，合成图层，显示在屏幕上。

**浏览器如果渲染过程中遇到 JS 文件怎么处理？**

渲染过程中，如果遇到<script>就停止渲染，执行 JS 代码。因为浏览器有 GUI 渲染线程与 JS 引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript 的加载、解析与执行会阻塞 DOM 的构建，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停构建 DOM，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复 DOM 构建。

也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。

JS 文件不只是阻塞 DOM 的构建，它会导致 CSSOM 也阻塞 DOM 的构建。

原本 DOM 和 CSSOM 的构建是互不影响，井水不犯河水，但是一旦引入了 JavaScript，CSSOM 也开始阻塞 DOM 的构建，只有 CSSOM 构建完毕后，DOM 再恢复 DOM 构建。

这是因为 JavaScript 不只是可以改 DOM，它还可以更改样式，也就是它可以更改 CSSOM。因为不完整的 CSSOM 是无法使用的，如果 JavaScript 想访问 CSSOM 并更改它，那么在执行 JavaScript 时，必须要能拿到完整的 CSSOM。所以就导致了一个现象，如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后在继续构建 DOM。

## Load 和 DOMContentLoaded 区别

  - Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。
  - DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。

## 复合线程

复合线程会将页面拆分图层进行绘制再进行复合。

## 图层

一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。

通过以下几个常用属性可以生成新图层
  - 3D 变换：translate3d、translateZ
  - will-change
  - video、iframe 标签
  - 通过动画实现的 opacity 动画转换
  - position: fixed

## async 和 defer 的作用和区别

1. <script src="script.js"></script>

没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。

2. <script async src="script.js"></script> (异步下载)

async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。

3. <script defer src="script.js"></script>(延迟执行)

defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。

defer 与相比普通 script，有两点区别：
  - 载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。
  - 在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。

## 重绘（Repaint）和回流（Reflow）

- 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘
  对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。

- 回流是布局或者几何属性需要改变就称为回流。
  对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来，这个过程就是回流（也叫重排）。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。

1. 常见引起回流属性和方法
任何会改变元素几何信息 (元素的位置和尺寸大小) 的操作，都会触发回流，
  - 添加或者删除 可见的 DOM 元素 / 样式；
  - 元素尺寸改变——边距、填充、边框、宽度和高度；
  - 内容变化，比如用户在 input 框中输入文字；
  - 浏览器窗口尺寸改变——resize 事件发生时；
  - 计算 offsetWidth 和 offsetHeight 属性；
  - 设置 style 属性的值；
  - 改变 window 大小 / 字体 / 文字；
  - 定位或者浮动

2. 常见引起重绘属性和方法
  - color
  - border-style
  - visibility
  - background
  - outline

3. 减少重绘和回流
  - 使用 translate 替代 top
  - 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）；
  - 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来；
  - 不要把节点的属性值放在一个循环里当成循环里的变量。可以使用 [FastDom](https://github.com/wilsonpage/fastdom) 批量对 DOM 进行读写操作。
  ```javaScript
    for (let i = 0; i < 1000; i++) {
      // 获取 offsetTop 会导致回流，因为需要去获取正确的值
      console.log(document.querySelector('.test').style.offsetTop)
    }
  ```

  - 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局；
  - 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame；
  - CSS 选择符从右往左匹配查找，避免节点层级过多, DOM 深度过深；
  - 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。

## 性能优化策略
基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。

- JS 优化： <script> 标签加上 defer 属性 和 async 属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。
- defer 属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。
- async 属性： HTML5 新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。
- CSS 优化： <link> 标签的 rel 属性 中的属性值设置为 preload 能够让你在你的 HTML 页面中可以指明哪些资源是在页面加载完成后即刻需要的，最优的配置加载顺序，提高渲染性能。

## 关键渲染路径优化
为了尽快完成页面的「首次渲染」，我们需要尽可能减少以下三种因素：

  - 关键资源的数量
    关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。

  - 关键路径长度
    关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。

  - 关键字节的大小
    浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。

1. 优化步骤
  1. 对关键路径进行「分析」和特性描述：资源数、字节数、长度。
  2. 最大限度「减少关键资源的数量」：删除它们，延迟它们的下载，将它们标记为异步等。
  3. 优化「关键字节数」以缩短下载时间（往返次数）。
  4. 优化其余关键资源的「加载顺序」：您需要尽早下载所有关键资产，以缩短关键路径长度。

2. 优化 JavaScript
   默认情况下，JavaScript 资源会阻塞解析器，除非将其标记为 async 或通过专门的 JavaScript 代码段进行添加。

   阻塞解析器的 JavaScript 会强制浏览器等待 CSSOM 并暂停 DOM 的构建，继而大大延迟首次渲染的时间。

  - 首选使用异步 JavaScript 资源
   「异步资源」不会阻塞文档解析器，让浏览器避免在执行脚本之前受阻于 CSSOM。
    
    通常，如果脚本可以使用 async 属性，也就意味着它并非首次渲染所必需（非关键资源）；可以考虑在首次渲染后异步加载脚本。

  - 避免运行时间长的 JavaScript
    运行时间长的 JavaScript 会阻止浏览器构建 DOM、CSSOM 以及渲染网页，所以任何对首次渲染无关紧要的初始化逻辑和功能都应延后执行。
    
    如果需要运行较长的初始化序列，请考虑将其拆分为若干阶段，以便浏览器可以间隔处理其他事件。

3. 优化 CSS
  - 将 CSS 置于文档 head 标签内
    尽早在 HTML 文档内指定所有 CSS 资源，以便浏览器尽早发现 <link> 标记并尽早发出 CSS 请求。

  - 避免使用 CSS import
    应避免使用这些指令，因为它们会在关键路径中增加往返次数：只有在收到并解析完带有 @import 规则的 CSS 样式表之后，才会发现导入的 CSS 资源。

  - 内联阻塞渲染的 CSS
    为获得最佳性能，您可能会考虑将关键 CSS 直接内联到 HTML 文档内。

    这样做不会增加关键路径中的往返次数，并且如果实现得当，在只有 HTML 是阻塞渲染的资源时，可实现「一次往返」关键路径长度。

## 总结

1. 浏览器工作流程：构建 DOM -> 构建 CSSOM -> 构建渲染树 -> 布局 -> 绘制。

2. CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。

3. 通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新 DOM 构建。
