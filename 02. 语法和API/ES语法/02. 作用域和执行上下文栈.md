## 作用域

作用域是指程序源代码中定义变量的区域。

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

`JavaScript` 采用**词法作用域**(lexical scoping)，也就是**静态作用域**。

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

函数的作用域基于函数创建的位置，在函数定义的时候就决定了，和函数是怎么调用的没有关系。

作用域其实可理解为该上下文中声明的变量和声明的作用范围。可分为 全局作用域、函数作用域和块级作用域。

作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

## 执行上下文

实际上变量和函数声明在代码里的位置是不会改变的，而且是在**编译阶段**被 `JavaScript` 引擎放入内存中。

- 变量提升：变量、函数表达式 —— 变量声明，默认赋值为`undefined`；

- `this` —— 赋值；

- 函数声明（通过 function 定义的函数） —— 赋值。**函数在定义的时候确定函数体内部自由变量的作用域**。

在编译阶段，变量和函数会被存放到变量环境中；在代码执行阶段，`JavaScript` 引擎会从变量环境中去查找自定义的变量和函数。

这些“准备工作”即为执行上下文[环境]，是当前 `JavaScript` 代码被解析和执行时所在环境的抽象概念。

## 可执行代码

`JavaScript` 的可执行代码 (executable code) 的类型有三种，全局代码、函数代码、eval 代码。

当 `JavaScript` 代码执行一段可执行代码 (executable code) 时，会创建对应的执行上下文 (execution context)。

- 全局执行上下文：当 `JavaScript` 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。浏览器中的全局对象就是 `window` 对象，`this` 指向这个全局对象。

- 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次**调用函数都会创建一个新的执行上下文**。函数执行结束之后，创建的函数执行上下文会被销毁。

- `Eval` 函数执行上下文：指的是运行在 `eval` 函数中文本形式的代码，很少用而且不建议使用。

为了管理创建执行上下文， `JavaScript` 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。

## 执行上下文栈

执行上下文栈，也叫调用栈，调用栈就是用来管理执行上下文（函数调用关系）的一种数据结构。具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。

首次运行 `JS` 代码时，会创建一个全局执行上下文并 `Push` 到当前的执行上下文栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 `Push` 到当前执行上下文栈的栈顶。

根据执行上下文栈 `LIFO` 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行上下文栈中 `Pop` 出，上下文控制权将移到当前执行上下文栈的下一个执行上下文。

通俗而言：执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。

其实这是一个压栈出栈的过程 —— 执行上下文栈。

![执行上下文栈](./images/执行上下文栈.jpeg)

调用栈是 `JavaScript` 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

### 栈溢出（Stack Overflow）

调用栈是有大小的，当入栈的执行上下文超过一定数目，`JavaScript` 引擎就会报错，把这种错误叫做栈溢出。

特别是在写没有任何终止条件的递归代码的时候，就很容易出现栈溢出的情况。它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。

[JavaScript 深入之词法作用域和动态作用域](https://github.com/mqyqingfeng/Blog/issues/3)

[JavaScript 深入之执行上下文栈](https://github.com/mqyqingfeng/Blog/issues/4)
