## 设计模式的分类

1. 创建型：指导解决创建对象方面的要求和问题。

2. 结构型：指导设计程序结构，也就是如何把对象或者类更好的组合成复杂的结构。

3. 行为型：指导如何组织对象的行为，划分对象职责和规划交流模式。

4. 技巧型：优化代码的特定技巧。


## 设计程序： 分析需求，设计出完成需求所需要的模块。

如何创建（创建型） =>  模块设计  =>  模块行为设计 + 代码实现 （结构型 + 行为型）


## 设计原则

一些名词：

  1. 低耦合：模块之间只存在消息交流，不存在功能上的强关联。不会彼此影响，可以随时拆分。

  2. 解耦：降低两个模块的耦合程度。

  3. 单一职责：一个模块只负责一个事情。

代码指标：

  1. 健壮性：代码面对无法控制的错误情况下，应对错误的能力，可以理解为现实中面对意外情况的应对能力。

  2. 可读性：代码结构简洁清晰，容易阅读。

  3. 可扩展性：面对功能的变更和修改，代码可以清晰且方便的扩展。不会因为修改引起代码的混乱和大规模重写。

  4. 复用性：可重复使用性。

设计原则：

  1. 开闭原则

  2. 接口隔离原则

  3. 单一原则

  4. 迪米特原则

  5. 依赖倒置原则

  6. 里氏替换原则


## 创建型设计模式

用途：创建对象、类

1. 工厂模式

目的：不关心对象的创建，更简单的获取到想要的对象。

应用场景：需要创建大量的对象，尤其当可能是各种对象的时候。

结构：构建一个工厂函数，通过调用这个工厂函数创建类，而不用具体去创建某个类。其实是一个依赖于抽象不依赖于具体的体现。

eg: JQuery


2. 建造者模式

目的：把对象的构建方案分离出来，使得同样的构建过程可以创建不同的表示。

应用场景：构建一个需要根据参数灵活配置的复杂对象。

结构：把最终的类分成不同的组成部分，独立出去，然后再组合在一起构建最终的类。

eg: Webpack


3. 单例模式

目的：一个类只能实例化一次。

应用场景：当创建的对象如果存在两个时会出现问题。

结构：通过一个标识，来判断是否已经实例化，如果已经实例化过一次，这个标识就会标识已经实例化过了。那么接下来的实例化将会无效。

eg: 创建一个唯一的储存器、vue-router


## 结构型设计模式

用途：设计模块，设计对象怎样组织。


1. 装饰者模式

目的： 代替继承去更好的扩展方法。

应用场景：需要扩展功能又不好直接修改的时候。

结构：三步走，重写新方法，调用老方法，加上新操作。

eg: 扩展事件绑定，Vue 的数组监听。

```javaScript
// Vue 的数组监听
let arrProto = Array.prototype;
let arrayMethods = Object.create(arrProto);

let arr = ["push", "pop", "shift"];
arr.forEach(method => {
  arrayMethods[method] = function() {
    let original = arrProto[method];
    let result = original.apply(this, args);
    dep.notify();
    return result;
  }
})
```


2. 适配器模式

目的：接口名字发生了改变，通过写一个适配器，来代替替换。

应用场景：面临接口不通用的问题。

结构：

eg: 框架的变更，参数的适配


3. 桥接模式

目的：抽象出代码的公用部分，提高代码的复用性。

应用场景：抽象核心功能一致，细节不同的方法。

结构：抽象公共代码再桥接回去。

eg: axios多种请求方法。


4. 享元模式

目的：减少重复代码块和重复对象。

应用场景：发现出现来类型重复的代码块和对象。

结构：把几个相似对象或者代码块的不同部分抽象出来作为享元数据，然后剩下的相同部分共享这些享元数据。


5. 外观模式

目的：简化多个子系统的调用

应用场景：某一个功能需要多个模块调用来完成时，提供一个集合的高级接口，让使用者只需要调用这个高级接口。




