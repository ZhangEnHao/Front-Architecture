## 面向对象

\+ public       

\# protected    

\- private      

三要素：继承、封装、多态


## 为何使用面向对象

程序执行： 顺序、判断、循环 —— 结构化

面向对象 —— 数据结构化

对于计算机，结构化的才是最简单的

编程应该 简单 & 抽象


## UML类图（Unified Modeling Language 统一建模语音）

UML 包含很多种图，和本课相关的是类图

关系，主要讲解 泛化 和 关联

1. 类图

| 类名 |
|:-:|
| + public 属性名A: 类型 <br> # protected 属性名B: 类型 <br> - private 属性名C: 类型 |
| + public 方法名A(参数1, 参数2): 返回值类型 <br> # protected 方法名A(参数1, 参数2): 返回值类型 <br> - private 方法名A(参数1, 参数2): 返回值类型 |

2. 关系

- 泛化：继承

- 关联：引用


## 设计原则

1. 何为设计

《UNIX/LINUX设计哲学》

  - 准则1: 小即是美

  - 准则2: 让每个程序只做好一件事

  - 准则3: 快速建立原型

  - 准则4: 舍弃高效率而取可移植性

  - 准则5: 采用纯文本存储数据

  - 准则6: 充分利用软件到杠杆效应（软件复用）

  - 准则7: 使用 shell 脚本提高杠杆效应和可移植性

  - 准则8: 避免强制性的用户界面

  - 准则9: 让每个程序都称为一个过滤器

2. 五大设计原则 —— SOLID

  - S —— 单一职责 —— 一个程序只做一件事，功能复杂就拆分，每个部分保持独立

  - O —— 开发封闭 —— 对扩展开发，对修改封闭 —— 增加需求时，扩展新代码，而非修改已有代码 —— 软件设计的终极目标

  - L —— 李氏置换 —— 子类可以覆盖父类，父类出现的地方子类就可以出现 JS使用较少（弱类型 & 继承使用较少）

  - I —— 接口独立

  - D —— 依赖导致

3. 从设计到模式

4. 23种设计模式

  - 创建型
    * 工厂模式（工厂方法模式、抽象工厂模式、建造者模式）
    * 单例模式
    * 原型模式

  - 组合型 （结构型）
    * 适配器模式
    * 装饰器模式
    * 代理模式
    * 外观模式
    * 桥接模式
    * 组合模式
    * 享元模式

  - 行为型
    * 策略模式
    * 模板方法模式
    * 观察者模式
    * 迭代器模式
    * 职责连模式
    * 命令模式

    * 备忘录模式
    * 状态模式
    * 访问者模式
    * 中介者模式
    * 解释器模式


## 面试题

1. 画出 UML 类图并用 ES6 编码

- 打车时，可以打专车或者快车。任何车都有车牌号和名称

- 不同车价格不同，快车每公里1元，专车每公里2元

- 行程开始时，显示车辆信息

- 行程结束时，显示打车金额

```JavaScript
class Trip {
  constructor(car, distance) {
    this.car = car;
    this.distance= distance;
  }

  start() {
    console.log(`行程开始，车辆信息: 名称${this.car.name}，车牌号${this.car.number}`);
  }

  end() {
    console.log(`行程结束，打车金额: ¥${this.car.price * this.distance}`);
  }
}

class Car {
  constructor(name, number) {
    this.name = name;
    this.number = number;
  }
}

class ZhuanChe extends Car {
  constructor(name, number, price) {
    super(name, number);
    this.price = price;
  }
}

class KuaiChe extends Car {
  constructor(name, number, price) {
    super(name, number);
    this.price = price;
  }
}

let carByZhuan = new ZhuanChe("Santana", 12345, 99);
let fareByZhuan = new Trip(carByZhuan, 2);
fareByZhuan.start();
fareByZhuan.end();
```

2. 画出 UML 类图并用 ES6 编码

- 某停车场，分 n 层，每层 m 车位

- 每个车位都能监控到车辆的驶入和离开

- 车辆进入前，显示每层的空余车位数量

- 车辆进入时，摄像头可以识别车牌号和时间

- 车辆出来时，出口显示器显示车牌号和停车时长

```JavaScript
// 车辆
class Car {
  constructor(num) {
    this.num = num
  }
}

// 摄像头 
class Camera {
  shot(car) {
    return {
      num: car.num,
      inTime: new Date()
    }
  }
}

// 显示器
class Screen {
  show(car, inTime) {
    console.log(`车牌号：${car.num}，停车时长：${new Date() - inTime}`);
  }
}

// 停车场
class Park {
  constructor(floors = []) {
    this.floors = floors
    this.camera = new Camera()
    this.screen = new Screen()
    this.carList = {} // 存储摄像头拍摄返回的车辆信息
  }
  in(car) {
    // 摄像头获取信息
    const info = this.camera.shot(car);
    // 停到某个车位
    const i = parseInt(Math.random() * 100 % 100);
    const place = this.floors[0].places[i];
    place.in()
    info.place = place
    // 记录信息
    this.carList[car.num] = info
  }
  out(car) {
    // 获取信息
    const info = this.carList[car.num];
    // 清空停车位
    const place = info.place;
    place.out()
    // 显示时间
    this.screen.show(car, info.inTime)
    // 清空记录
    delete this.carList[car.num]
  }
  emptyNum() {
    return this.floors.map(floor => {
      return `${floor.index}层还有${floor.emptyPlaceNum()}个空闲车位`
    }).join("\n");
  }
}

// 楼层
class Floors {
  constructor(index, places = []) {
    this.index = index
    this.places = places
  }
  emptyPlaceNum() {
    let sum = 0;
    this.places.forEach(p => {
      if (p.empty) sum++
    })
    return sum
  }
}

// 车位
class Place {
  constructor() {
    this.empty = true
  }
  in() {
    this.empty = false
  }
  out() {
    this.empty = true
  }
}

// test
// 初始化停车场
let floors = [];
for(let i = 0; i < 3; i++) {
  let places = [];
  for(let j = 0; j < 100; j++) {
    places[j] = new Place();
  }
  floors[i] = new Floors(i+1, places)
}

let park = new Park(floors);

// 初始化车辆
let car1 = new Car(100);
let car2 = new Car(200);
let car3 = new Car(300);

console.log(park.emptyNum());
park.in(car1);
console.log(park.emptyNum());
park.in(car2);
console.log(park.emptyNum());
park.out(car1);
console.log(park.emptyNum());
park.out(car2);
console.log(park.emptyNum());


park.in(car3);
console.log(park.emptyNum());
park.out(car3);
console.log(park.emptyNum());
```





