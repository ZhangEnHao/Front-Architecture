## 概述

`ES6` 发布前，`JavaScript` 只能通过 `var` 声明变量的方式，常量、块级变量、函数变量这些概念的差别都不能很好的体现出来，于此同时，加入你要使用或者提供一个 `API`，`var` 声明的变量可随时被修改和重新分配的问题，会让你时刻担心代码是否能正常运行。

`ES6` 带来了 `let`、`const`，先来了解一下三个标识符的特征：

- `var` ： 声明变量， 其作用域为该语句所在的函数内，且存在变量提升现象；
- `let` ： 声明变量， 其作用域为该语句所在的代码块内，不存在变量提升；
- `const` ：声明常量， 不能再修改该常量的值， 实质是不能修改的是**栈内存在的值**（基本类型的直接值）和**地址**（引用类型值存在的对应的地址）。

所谓的**变量提升**，是指在 `JavaScript` 代码执行过程中，`JavaScript` 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是 `undefined`。

由于变量提升作用，使用 JavaScript 来编写和其他语言相同逻辑的代码，都有可能会导致不一样的执行结果。主要有以下两种原因。

- 1. 变量容易在不被察觉的情况下被覆盖掉

- 2. 本应销毁的变量没有被销毁

## 块级作用域

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

`ES5` 只有**全局作用域**和**函数作用域**，没有块级作用域。

- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。

-   函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。


`ES6` 的块级作用域: `let` 实际上为 `JavaScript` 新增了块级作用域。

块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 `{}` 都可以被看作是一个块级作用域。

简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

### 块级作用域与函数声明

**ES5** 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

**ES6** 引入了块级作用域，明确允许在块级作用域之中声明函数。**ES6** 规定，块级作用域之中，函数声明语句的行为类似于 `let`，在块级作用域之外不可引用。

**ES6 的块级作用域必须有大括号**，如果没有大括号，`JavaScript` 引擎就认为不存在块级作用域。

如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，`ES6` 在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

- 允许在块级作用域内声明函数。
- 函数声明类似于 `var`，即会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。

```javaScript
function f() { 
    console.log('I am outside!');
}

(function () {
    if (false) {
        // 重复声明一次函数 f
        function f() { console.log('I am inside!'); }
    }
    f();
}());

// 上面代码在 ES5 中运行，会得到“I am inside!”
// 浏览器的 ES5 环境
function f() { 
    console.log('I am outside!');
}

(function () {
    function f() { 
        console.log('I am inside!');
    }
    if (false) {}
    f();
}());

// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }

(function () {
    var f = undefined;
    if (false) {
        function f() { console.log('I am inside!'); }
    }
    f();
}());
// Uncaught TypeError: f is not a function
```

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

## `let` 命令

### 1. 暂时性死区

ES6 明确规定，如果区块中存在 `let` 和 `const` 命令，这个区块对这些命令声明的变量，从一开始就形成了**封闭作用域**。凡是在声明之前就使用这些变量，就会报错。

在代码块内，使用 `let` 命令**声明变量之前，该变量都是不可用的**。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

### 2. 不存在变量提升

`let` 命令所声明的变量一定要**先声明后使用**，否则报错。

### 3. 不允许重复声明

`let` 不允许在相同作用域内，重复声明同一个变量。

## const 命令

### 1. 基本用法

- `const` 声明一个只读的常量。一旦声明，常量的值就不能改变。

- `const` 声明的常量不得改变值，这意味着，const 一旦声明常量，就必须立即初始化，不能留到以后赋值。

- 存在暂时性死区，只能在声明的位置后面使用。

- 只在声明所在的块级作用域内有效。

- 不可重复声明。

### 2. 本质

常量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。

`const` 修改演示：

```javaScript
const a = []; 
a.push('Hello'); // 可执行 a.length = 0; // 可执行 a = ['Dave']; // 报错 
```

```javaScript
/** 可修改 **/
// 修改对象属性
const obj = {a:1}
obj.a=2
obj.b=2

/** 不可修改 **/
const obj = {a:1}
obj = {a:2}

const a = new String('123') ;
a = '456'；
/**
 * - 原理
 * - temp = new String('456')
 * - a = temp
 * - 销毁 temp
 * 
*/
```

### 3. 冻结对象

如果真的想将对象冻结，应该使用 `Object.freeze` 方法。

```javaScript
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```

**除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。**

```javaScript 
let constantize = obj => { 
    Object.freeze(obj); 
    Object.keys(obj).forEach( (key, i) => { 
        if ( typeof obj[key] === 'object' ) { 
            constantize( obj[key] ); 
        } 
    }); 
}; 
```

## ES6 声明变量的六种方法

**ES5** 只有两种声明变量的方法：`var` 命令和`function` 命令。

**ES6** 除了添加 `let` 和 `const` 命令，后面章节还会提到，另外两种声明变量的方法：`import` 命令和 `class` 命令。所以，`ES6` 一共有 6 种声明变量的方法。

### 1. `globalThis` 对象

`JavaScript` 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。

- 浏览器里面，顶层对象是 `window` ，但 `Node` 和 `Web Worker` 没有 `window`。
- 浏览器和 `Web Worker` 里面，`self`也指向顶层对象，但是 `Node` 没有`self`。
- `Node` 里面，顶层对象是`global`，但其他环境都不支持。

同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 `this` 变量，但是有局限性。

- 全局环境中， `this` 会返回顶层对象。但是，Node 模块和 ES6 模块中，`this` 返回的是当前模块。
- 函数里面的 `this` ，如果函数不是作为对象的方法运行，而是单纯作为函数运行，`this` 会指向顶层对象。但是，严格模式下，这时 `this` 会返回 `undefined`。
- 不管是严格模式，还是普通模式，`new Function('return this')()`，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么`eval`、`new Function`这些方法都可能无法使用。

综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。

```javaScript
// 方法一
(typeof window !== 'undefined'
? window
: (typeof process === 'object' &&
typeof require === 'function' &&
typeof global === 'object')
? global
: this);

// 方法二
var getGlobal = function () {
if (typeof self !== 'undefined') { return self; }
if (typeof window !== 'undefined') { return window; }
if (typeof global !== 'undefined') { return global; }
throw new Error('unable to locate global object');
};
```

**ES2020** 在语言标准的层面，引入 `globalThis` 作为顶层对象。也就是说，任何环境下， `globalThis` 都是存在的，都可以从它拿到顶层对象，指向全局环境下的 `this`。

垫片库`global-this`模拟了这个提案，可以在所有环境拿到 `globalThis`。

### 2. 顶层对象的属性

顶层对象，在浏览器环境指的是 `window` 对象，在 `Node` 指的是 `global` 对象。

**ES5** 之中，顶层对象的属性与全局变量是等价的。

**ES6** 为了改变这一点，一方面规定，为了保持兼容性，`var` 命令和 `function` 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let` 命令、`const` 命令、`class` 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 `ES6` 开始，全局变量将逐步与顶层对象的属性脱钩。

## 交换两个变量值的七种方式

```javaScript
let a=10,b=20;
// one 使用第三个变量(最简单，但不推荐)
let t = a;
a = b;
b = t;

// two 做加减 (只针对数字)
a += b;
b = a - b;
a -= b;

// three 使用位运算异或 (只能进行数字的交换)
// 异或:只有其中一个是 1，另一个是 0，最终才是 1，否则为 0
a = a^b;
b = a^b;
a = a^b;

// four
[a,b] = [b,a];

// five 万能法(任何数据类型都可以转换，推荐使用)
a = [b,b=a][0];

// six
a = {a:a,b:b};
b = a.a;
a = a.b;

// seven
a = [a,b];
b = a[0];
a = a[1];
```

## 关于同名变量和函数的处理原则

1. 如果是同名的函数，`JavaScript` 编译阶段会选择最后声明的那个。

2. 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略。但是会被变量赋值之后覆盖。

参考文章：

[let 和 const 命令](http://es6.ruanyifeng.com/#docs/let)

[我用了两个月的时间才理解 let](https://fangyinghang.com/let-in-js/)

[JavsScript 变量提升和函数提升](https://towind.fun/2021/05/10/js-hoisting/#/JS-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87)
