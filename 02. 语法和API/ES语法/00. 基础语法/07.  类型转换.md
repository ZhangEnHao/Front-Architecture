## 类型转换规则

| 转换前类型 | 转换前值        | 转换后（Boolean） | 转换后（Number） | 转换后（String）  |
| :--------- | :-------------- | :---------------- | :--------------- | :---------------- |
| Boolean    | true            | true              | 1                | "true"            |
| Boolean    | false           | false             | 0                | "false"           |
| Number     | 123             | true              | 123              | "123"             |
| Number     | Infinity        | true              | Infinity         | "Infinity"        |
| Number     | 0               | false             | 0                | "0"               |
| Number     | NaN             | false             | NaN              | "NaN"             |
| String     | ""              | false             | 0                | ""                |
| String     | "123"           | true              | 123              | "123"             |
| String     | "123TYPE"       | true              | 123              | "123TYPE"         |
| String     | "TYPE"          | true              | NaN              | "TYPE"            |
| Null       | null            | false             | 0                | "null"            |
| Undefined  | undefined       | false             | NaN              | "undefined"       |
| Symbol     | Symbol()        | true              | TypeError        | TypeError         |
| Function   | function(){}    | true              | NaN              | "function(){}"    |
| Object     | {}              | true              | NaN              | "[object Object]" |
| Array      | []              | true              | 0                | ""                |
| Array      | ["TYPE"]        | true              | NaN              | "TYPE"            |
| Array      | ["123", "TYPE"] | true              | NaN              | "123,TYPE"        |

## 强制类型转换

强制类型转换方式包括 `Number()`、`parseInt()`、`parseFloat()`、`toString()`、`String()`、`Boolean()`，这几种方法都比较类似，都是通过自身的方法来进行数据类型的强制转换。

### 注意

1. `Number()` 方法的强制转换规则

- 如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 `NaN`；

- 如果是对象，并且部署了 `[Symbol.toPrimitive]` ，那么调用此方法，否则调用对象的 `valueOf()` 方法，然后依据前面的规则转换返回的值；如果转换的结果是 `NaN` ，则调用对象的 `toString()` 方法，再次依照前面的顺序转换返回对应的值。

2. `Boolean()` 方法的强制转换规则

除了 `undefined`，`null`，`false`，`NaN`，`''`， `0`，`-0`转换出来是 `false`，其他所有值都转为 `true`，包括所有对象。

3. 除了不同类型的转换之外，操作同种数据类型也会发生转换。把基本类型的数据换成对应的对象过程称之为“装箱转换”，反过来，把数据对象转换为基本类型的过程称之为“拆箱转换”。

对于装箱和拆箱转换操作，我们既可以显示地手动实现，比如将 Number 数据类型转换成 Number 对象；也可以通过一些操作触发浏览器显式地自动转换，比如将对 Number 对象进行加法运算。

```javaScript
var n = 1
var o = new Number(n) // 显式装箱
o.valueOf() // 显式拆箱
n.toPrecision(3) // 隐式装箱, 实际操作：var tmp = new Number(n);tmp.toPrecision(3);tmp = null;
o + 2 // 隐式拆箱，实际操作:var tmp = o.valueOf();tmp + 2;tmp = null;
```

## 隐式类型转换

凡是通过逻辑运算符 (`&&`、 `||`、 `!`)、运算符 (`+`、`-`、`*`、`/`)、关系操作符 (`>`、 `<`、 `<=` 、`>=`)、相等运算符 (`==`) 或者 `if` / `while` 条件的操作，如果遇到两个数据类型不一样的情况，都会出现隐式类型转换。

### [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

运算符的优先级决定了表达式中运算执行的先后顺序。优先级高的运算符会作为优先级低的运算符的操作符。

常用的，从**上到下从高到低排序，同级内按书写时从左到右排序**：

- `()` 分组子表达式；

- `.` 成员访问`[]`、 需计算的成员访问、`()` 函数调用；

- `...++` 后置递增、`...--` 后置递减；

- `!` 逻辑非、`~` 按位非、`+...` 一元加法、`-...` 一元减法、`++...` 前置递增、`--...`、前置递减；

- `**` 幂、`*` 乘法、`/` 除法、`%` 取余；

- `+` 加法、`-` 减法；

- `<` 小于、 `<=` 小于等于、 `>` 大于、 `>=` 大于等于；

- `==` 相等、`!=` 不相等、`===` 一致/严格相等、`!== ` 不一致/严格不相等；

- `&` 按位与

- `^` 按位异或

- `|` 按位或

- `&&` 逻辑与；

- `||` 逻辑或；

- `??` 空值合并；

- `...?...:...` 条件（三元）运算符；

### `==` 相等的隐式类型转换规则

1. 如果类型相同，无须进行类型转换；

2. 如果其中一个操作值是 `null` 或者 `undefined`，那么另一个操作符必须为 `null` 或者 `undefined`，才会返回 `true`，否则都返回 `false`；

3. 如果其中一个是 `Symbol` 类型，那么返回 `false`；

4. 两个操作值如果为 `string` 和 `number` 类型，那么就会将字符串转换为 `number`；

5. 如果一个操作值是 `boolean`，那么转换成 `number`；

6. 如果一个操作值为 `object` 且另一方为 `string`、`number` 或者 `symbol`，就会把 `object` 转为原始类型再进行判断（调用 `object` 的 `valueOf` / `toString` 方法进行转换）。

### `+` 加号运算符的隐式类型转换规则

1. 首先执行代码，调用 对象转换成基础类型 方法得到原始值。

2. 如果两个原始值都是 `number`，则直接相加得出结果。

3. 如果其中有一个原始值是 `number`，另外一个原始值是 `undefined`、`null`、`boolean`，则会将其转换成数字进行加法运算。

4. 如果两个原始值都是 `string`，把第二个字符串连接到第一个上，也就是相当于调用 `concat` 方法。

5. 如果只有一个原始值是 `string`，另外一个是 `undefined`、`null`、`boolean` 或 `number`，则调用 `String` 或者 `toString` 方法把另一个运算数转换成 `string` 进行字符串拼接。

注意：不能把 `BigInt` 和 `Number` 类型直接混合相加。

```javaScript
1 + '1' // '11'
2 * '2' // 4

/**
* [1, 2].toString() -> '1,2'
* [2, 1].toString() -> '2,1'
* '1,2' + '2,1' = '1,22,1'
*/ 
[1, 2] + [2, 1] // '1,22,1'


/**
* 对于加号需要注意表达式 'a' + + 'b'
* 因为 + 'b' -> NaN
*
*/ 
'a' + + 'b' // -> "aNaN"

+ '1' // 1
```

### `Object` 对象的隐式类型转换规则

「对象」转换成「原始类型」的值，其规则逻辑如下：

1. 如果部署了 `Symbol.toPrimitive` 方法，优先调用再返回；

2. 调用 `valueOf()`，如果转换为基础类型，则返回；

3. 调用 `toString()`，如果转换为基础类型，则返回；

3. 如果上面三步都没有返回基础类型，则报错。

```javaScript
var obj = {
  value: 1,
  valueOf() {
    return 2;
  },
  toString() {
    return '3'
  },
  [Symbol.toPrimitive]() {
    return 4
  }
}
/**
* 因为有 Symbol.toPrimitive ，就优先执行这个方法；
* 如果将 Symbol.toPrimitive 方法删掉，则执行 valueOf 打印结果为3；
* 如果 valueOf 也去掉，则调用 toString 返回'31'(字符串拼接)
*/ 
console.log(obj + 1); // 输出5

/**
* [1,2,undefined,4,5] 会默认先调用 valueOf 结果还是这个数组，不是基础数据类型继续转换，
* 调用toString，返回 "1,2,,4,5"，
* 然后再和 10 进行运算，还是按照字符串拼接规则
*/ 
[1,2,undefined,4,5] + 10 // '1,2,,4,510'
```

## `{}` 是对象还是代码块

一些例子：

```javaScript
{a: 1}[1] // [1]

{a: 1}['a'] // ["a"]

({a: 1})['a'] // 1

({a: 1,})['a'] // 1

{a: 1,}['a'] // Uncaught SyntaxError: Unexpected token '}'

{a: 1}[] // []
```

特点：

- 当 `{}` 前面有运算符号的时候，`+，-，*，/，()` 等等， `{}` 都会被解析成「对象字面量」；

- 当 `{}` 前面没有运算符时候但有 `;` 结尾的时候，或者浏览器的自动分号插入机制给 `{}` 后面插入分号 `;` 的时候，此时 `{}` 都会被解析成「代码块」。

- 当 `()` 括号包裹时 `{}` 就变成了对象组成表达式。

也就是说 `{}` 后有 `;` 结尾，前无符号，`{}` 才会被翻译为「代码块」。

验证：

```javaScript
{} // {} => 对象 

{}; // undefined => 代码块

/**
 * "" [].valueOf() === []，[].toString() === ""
 * [] + [] === "" + ""
 * */ 
[] + [] // "" 

/**
 * [] + {} === "" + "[object Object]"
 * */ 
[] + {} // "[object Object]"

/**
 * {} 被当作空的代码块
 * 事实上这个表达式的值就是 +[] 的结果
 * 即 Number([].join(','))，即为`0`
 * Number([].toString()) => Number("") => 0
 * */ 
{} + [] // 0

/**
 * + {} => Number({}) => Number({}.toString()) => Number("[object Object]") => NaN
 * */ 
+ {} // NaN => 对象 
{} + {}; // NaN => 代码块（被忽略） + 对象

{} + {} // "[object Object][object Object]" => 对象 + 对象 

/**
* {} 做为对象会默认调用 valueOf 还是 {}，
* 不是基础类型继续转换，调用 toString ，返回结果 "[object Object]"，
* 于是和 10 进行 '+' 运算，按照字符串拼接规则来
*/
10 + {} // '10[object Object]'

/**
* {} 当作空的代码块忽略，实际上运行的是 + 10，
* 相当于 Number(10) 结果还是 10;
* 于是和 10 进行 '+' 运算，按照字符串拼接规则来
*/
{} + 10 // 10
```


## 类型转换举例

```javaScript
({}+1) // "[object Object]1"
// 错误：1，把 {} 看做代码块
// 正确：{} 前有括号，看做对象，调用对象的 `({}.toString)` 得到 `"[object Object]"`

1+[] // "1"
// 错误：1，把 [] 转换成了 Number
// 正确：`+` 号两边转为原始类型，`[].toString()`，得到 `""`

1-[] // 1
// 正确：`-` 号两边均转为 Number 类型，`Number([])` 得到 `0`

1-{} // NaN
// 正确：`-` 号两边均转为 Number 类型，`Number({})` 得到 `NaN`

1-!{} // 1
// 正确：`!` 一元逻辑非的优先级高于 `-` 二元减法，所以先进行 `![]` 运算，得到 `false`，`1-false` 将 `false` 转为 `Number` 得到 `0`

1+!{} // 1
// 正确：`!` 一元逻辑非的优先级高于 `-` 二元加法，所以先进行 `![]` 运算，得到 `false`，`1+false` 将 `false` 转为 `Number` 得到 `0`

1+"2"+"2" // "122"
// 正确：只要加号两边有一个字符串就全部转为字符串进行拼接

1+ +"2"+"2" // "32"
// 错误："122"，当做 1+ (2+"2")
// 正确：`1+` 后有空格，第一个 `+"2"` 前的 `+` 为一元加法，优先级高，相当于进行 `1+(+"2")+"2"`，得到 `1+2+"2"` 相当于 `3+"2"`

1++"2"+"2" // ReferenceError
// 错误：NaN
// 正确：++后面需要跟一个引用类型

[]==![] // true
// 错误：false，当做两边均转为 Number，一边 1 一边 0
// 正确：先进行布尔运算，得到 `[]==false` => `""==false` => `0==0`

[]===![] // false
// 正确：先进行布尔运算，得到 `[]===false`
```

一个比较少见的例子：

```javaScript
{}+[] == []+{}  // true 
{}+[] == []+{}; // false
```

### 验证分析 `++[[]][+[]] + [+[]] == 10`

1. 根据优先级拆分出 + 二元加号

```javaScript
(++[[]][+[]])

- ([+[]])
```

2. 先分析左边：`++[[]][+[]]`

- 1. `[]` 成员访问的优先级高，先计算 `[[]][+[]]`；

- 2. `+[]` 相当于 `Number([])`，得到 0；原式相当于 `++[[]][0]`；

- 3. `[[]][0]` 显而易见，结果是取 `[[]]` 数组中的第一位，即 `[]`；原式相当于 `++[]`；

- 4. 最后来分析 `++[]`。

在英文版的 ECMAScript 规范中要求（前缀、后缀）自增的内容，必须是一个引用，才不会报错(Uncaught ReferenceError: Invalid left-hand side expression in prefix operation)。

`[[]][0]` 是对象的属性访问，拿到的 `[]` 自然是一个引用；

所以，`++[]` 相当于 `Number([])+1`，得到 1。

- 5. 所以左边 `++[[]][+[]] = 1`；

3. 再分析右边：`[+[]]`

`+[]` 为 0，结果为 `[0]`；

4. 结合左右两边式子，得到 `1+[0]`，其中 `[0]` 进行 `ToPrimitive` 对象转换成基础类型，得到 `"0"`，原式相当于 `1+"0"`，故得 `"10"`。

5. `"10" == 10`

### `[] == ![]` 结果是什么？为什么？

`==` 中，左右两边都需要转换为数字然后进行比较。

左边 `[]` 转换为数字为 0。

右边 `![]` 首先是转换为布尔值，由于 `[]` 作为一个引用类型转换为布尔值为 `true`，因此 `![]` 为 `false`，进而在转换成数字，变为 `0`。

`0 == 0` ， 结果为 `true`。

### 如何让 `if(a == 1 && a == 2)` 条件成立？

「对象」转换成「原始类型」值规则的应用。

```javaScript
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
console.log(a == 1 && a == 2); //true
```
