## CPU 和 GPU

### CPU

中央处理器（Central Processing Unit），也就是常说的 CPU。

CPU 可以看作是整个计算机的大脑。当有不同的任务传递进来时，它可以一个一个的去处理这些任务。当 CPU 知道如何响应人们的需求时，它几乎可以处理各式各样的任务，比如数学，或是艺术。在早些年，CPU 都是由单芯片所构成。每个核就像是在芯片中又存在着另一个 CPU。现代的电子设备基本上都是多核驱动的，这让人们的手机和电脑都具备了更强的计算能力。

### GPU

图形处理器（Graphics Processing Unit），也就是 GPU。

和 CPU 不同的是，GPU 擅长同时处理跨多核的简单任务。正如它的名字，在设计之初是用来处理图形的。这也正是为什么当图形任务的处理和 GPU 关联起来的时候，通常带来的都是更快速的渲染和更流畅的交互。近年来，随着 GPU 的不断加速和升级，越来越多的计算都可能直接被放在 GPU 上进行了。

当在手机或电脑上启动一个应用时，CPU 和 GPU 就是为那个应用提供“能量”的两个小兄弟。通常，应用程序通过操作系统提供的“机制”在 CPU 和 GPU 上运行。

## 进程（Process）与线程（Thread）

进程是操作系统进行资源分配和调度的基本单位，线程是操作系统进行运算的最小单位。一个程序至少有一个进程，一个进程至少有一个线程。线程需要由进程来启动和管理。

### 并行处理

计算机中的并行处理就是同一时刻处理多个任务，使用并行处理能大大提升性能。

通常程序需要执行多个任务，比如浏览器需要一边渲染页面一边请求后端数据同时还要响应用户事件，而单线程的进程在同一时间内只能执行一个任务，无法满足多个任务并行执行的需求。要解决这个问题，可以通过 3 种方式来实现：

- 多进程

- 多线程（同一进程）

- 多进程和多线程

由于第 3 种方式是前两种方式的结合，所以只比较多进程和多线程的特点。

前面提到进程是操作系统资源分配的基本单位，这里隐含的意思就是，不同进程之间的资源是独享的，不可以相互访问。这种特性带来的最大好处就是建立了进程之间的隔离性，避免了多个进程同时操作同一份数据而产生问题。

而多线程没有分配独立的资源，线程之间数据都是共享的，也就意味着创建线程的成本更小，因为不需要分配额外的存储空间。但线程的数据共享也带来了很多问题：首先是稳定性，进程中任意线程崩溃都会导致整个进程的崩溃，也就是说会“牵连”到进程中的其他线程。安全隐患就更容易理解了，如果有恶意线程启动，可以随意访问进程中的任意资源。

总而言之，多线程更轻量，多进程更安全更稳定。

### 线程 VS 进程

多线程可以并行处理任务，但是**线程是不能单独存在的，它是由进程来启动和管理的**。

**一个进程就是一个应用程序的运行实例。线程则是进程内部用来执行某个部分的程序。**详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，把这样的一个运行环境叫进程。

![单线程与多线程的进程对比图](../../images/singleThreadedAndMultiThreadedProcessComparisonDiagram.png)

从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

总结来说，进程和线程之间的关系有以下 4 个特点。

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。

2. 线程之间共享进程中的数据。

如下图所示，线程之间可以对进程的公共数据进行读写操作。

![线程之间共享进程中的数据示意图](../../images/sharedProcessData.png)

从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。

3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。

当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

4. 进程之间的内容相互隔离。

进程可以让操作系统再另起一个进程去处理不同的任务。当这种情况发生时，新的进程又将占据一块内存空间。

进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。

正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。

如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（Inter Process Communication IPC）的机制了。

## 单进程浏览器时代

顾名思义，**单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里**，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：

![单进程浏览器架构示意图](../../images/SchematicDiagramOfSingle-processBrowserArchitecture.png)

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。

### 问题 1：不稳定

早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。

除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。

### 问题 2：不流畅

从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。

如果让一个无限循环的脚本运行在一个单进程浏览器的页面里，当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。

除了上述**脚本**或者**插件**会让单进程浏览器变卡顿外，**页面的内存泄漏**也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。

### 问题 3：不安全

这里依然可以从插件和页面脚本两个方面来解释该原因。

插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。

至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。

## 多进程浏览器时代

### 早期多进程架构

2008 年 Chrome 发布时的进程架构图

![早期 Chrome 进程架构图](../../images/EarlyChromeProcessArchitectureDiagram.png)

从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分）。

1. 如何解决不稳定的问题。

由于进程是相互隔离的，每个选项卡都有自己的渲染器进程。所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。

2. 不流畅的问题是如何解决的。

JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。

对于内存泄漏，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。

3. 安全问题是怎么解决的。

由于操作系统提供了一种限制进程权限的方法，因此采用多进程架构的浏览器可以对某些进程的某些功能进行沙箱处理。你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

4. 站点隔离（Site Isolation）

站点隔离是 Chrome 在其 67 桌面版上新增的特性，基本原则是不同的站点各自运行在自己的沙箱环境中，独享进程，并且不允许通信。

每个窗口一个进程的模型，在这个模型中，浏览器允许跨站点的 iframe 独立进程共享不同站点之间的内存空间。早先在一个渲染进程中（窗口）同时运行 a.com 和 b.com 看起来没有什么问题，因为有同源策略，确保一个站点未经同意就无法访问其他站点的数据。绕过同源策略基本上成为了所有安全攻击的指导方针。而进程间的相互隔离是将站点分开的最佳途径（感兴趣可以去了解一下 Meltdown 和 Spectre 攻击）。

经过多年的工程上的努力，如今的站点隔离已经默认为用户开启了。事实上，站点隔离并不仅仅是为站点分配不同的渲染进程这么简单，它从根本上改变了 iframe 之间的通信方式。打开运行有不同站点 iframe 的开发者工具，意味着浏览器必须做很多看不到的幕后工作，才能让这一切看起来和以前没有什么区别，即使是简简单单的 ctrl+F 在这个场景下也意味着在不同的渲染进程中查询字符串。网上有很多文章介绍浏览器的站点隔离策略，当你看完那些之后就会意识到，为什么站点隔离值得 Chrome 团队为其发布一个独立版本了。

### 目前多进程架构

![最新的 Chrome 进程架构图](../../images/TheLatestChromeProcessArchitectureDiagram.png)

从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

#### 浏览器进程（Browser Process）

主要负责控制浏览器这个应用的 chrome（主框架）部分

- UI 线程负责浏览器界面显示，与用户交互。包括地址栏、书签、前进/后退按钮等。

- 负责各个页面的管理，创建和销毁其他进程。

- 子进程管理：将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上。

- 存储线程控制着访问本地文件的权限。

- 同时也会处理浏览器不可见的高权限任务，如网络线程负责处理并接收来自互联网的网络资源、下载、发送网络请求、文件访问。

#### 渲染进程（Renderer Process）

浏览器会为每个标签页单独启动一个渲染进程，所以它和其他进程不同，并不是唯一的。内部是多线程的。

渲染进程的核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，每个渲染进程都会启动单独的渲染引擎线程、 `JavaScript` 引擎线程和排版引擎 Blink。

除此之外还包括事件触发线程，负责接收事件，并将回调函数放入 `JavaScript` 引擎线程的事件队列中，以及负责处理定时任务的定时器线程。

这种设计保障了程序与系统的安全性，可以通过操作系统提供的权限机制来为每个渲染进程建立一个沙箱运行环境，从而防止恶意破坏用户系统或影响其他标签页的行为。

同时也保障了渲染进程的稳定性，因为如果某个标签页失去响应，用户可以关掉这个标签页，此时其他标签页依然运行着，可以正常使用。如果所有标签页都运行在同一进程上，那么当某个失去响应，所有标签页都会失去响应。

默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程有多层，表示 Chrome 为每个选项卡运行多个渲染器进程。

在最近的一次更新中，如果够用的话，Chrome 干脆给每个窗口分配了一个进程；而现在，Chrome 在致力于给每个站点一个独立的进程，包括 iframe。

#### GPU 进程

其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后 Chrome 在其多进程架构上也引入了 GPU 进程。在独立的进程中处理 GPU 任务。之所以放到独立的进程，是因为 GPU 要处理来自多个应用程序的请求，但要在同一个界面上绘制图形。

GPU 进程处理来自其他进程的 GPU 任务，比如来自渲染进程或扩展程序进程的 `CSS3` 动画效果，来自浏览器进程的界面绘制等。

在浏览器渲染页面的过程的最后一个步骤“绘制”中提到了图层的合成，而这个图层的合成操作其实就是交给 GPU 进程来完成的。

它还有一个重要的特性，那就是可以利用 GPU 硬件来加速渲染，包括 `Canvas` 绘制、`CSS3` 转换（`Transitions`）、`CSS3` 变换（`Transforms`）、`WebGL` 等。具体原理就是如果 `DOM` 元素使用了这些属性，GPU 进程就会在合成层的时候对它进行单独处理，提升到一个独立的层进行绘制，这样就能避免重新布局和重新绘制。

利用 `keyframes` 实现一个动画，在页面绘制完成后，浏览器没有再进行布局或绘制相关的操作。因此此时元素的绘制工作已经脱离了渲染引擎，交由 GPU 进程来维护。

#### 网络进程（Network Service）

主要负责页面的网络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。之前是作为一个模块运行在浏览器主进程里面的，现在为了将浏览器进程进行“服务化”，被抽取出来，成了一个单独的进程。

#### 插件（扩展程序）进程

主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。和渲染进程一样，也不是唯一的，浏览器会为每个插件都启动一个进程。这样的设计也是从安全性和稳定性考虑。

所以，仅仅打开了 1 个页面，为什么有 4 个进程的原因就在于打开 1 个页面至少需要 1 个浏览器进程、 1 个渲染进程、1 个 GPU 进程以及 1 个网络进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

#### V8 代理解析工具进程

Chrome 支持使用 `JavaScript` 来写连接代理服务器脚本，称为 pac 代理脚本。

由于 pac 代理脚本是用 `JavaScript` 编写的，要能够解析 pac 代理脚本就必须要用到 `JavaScript` 脚本引擎，直接在浏览器主进程中引入 `JavaScript` 引擎并不符合进程“服务化”的设计理念，所以就把这个解析功能独立成一个进程。

不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

- **更高的资源占用**。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。

- **更复杂的体系架构**。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。

### 未来面向服务的架构

为了解决这些问题，在 2016 年，Chrome 官方团队使用“**面向服务的架构**”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而**构建一个更内聚、松耦合、易于维护和扩展的系统**，更好实现 Chrome 简单、稳定、高速、安全的目标。

Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：

![Chrome“面向服务的架构”进程模型图](../../images/ChromeServiceOrientedArchitectureProcessModelDiagram.png)

Chrome 正在逐步构建 Chrome 基础服务（Chrome Foundation Service），如果你认为 Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。

Chrome 的服务化可以节省更多的内存。

- Chrome 将浏览器程序的每个部分作为服务运行，从而允许轻松拆分为不同的进程或聚合为一个。

- 同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会将每个服务拆分为不同的进程以多进程的方式运行基础服务以提供更高的稳定性和健壮性，但是如果在资源受限的设备上，Chrome 会将很多服务整合到一个进程中，从而节省内存占用。像这种通过整合进程资源以此来节省内存的手段，已经被用于 Android 上了。

![在资源不足的设备上，将服务合并到浏览器进程中](../../images/serviceConsolidation.png)

## 总结

本文主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。

最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式，这也是 Chrome 团队现阶段的一个主要任务。

鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过 Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到 Chrome 新的变化。

总体说来，Chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利。

## 答疑

### 即使是如今的多进程架构，偶尔还会碰到一些由于单个页面卡死最终崩溃导致所有页面崩溃的情况的原因

通常情况下是一个页面使用一个进程，但是，有一种情况，叫"同一站点(same-site)"，具体地讲，将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：

```
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```

都是属于同一站点，因为它们的协议都是 `https`，而根域名也都是 `geekbang.org`。

Chrome 的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 `process-per-site-instance`。

直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。

所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。

而要让他们跑在一个进程里是因为在一个渲染进程里面，他们会共享 JS 的执行环境，也就是说 A 页面可以直接在 B 页面中执行脚本。因为是同一家的站点，所以是有这个需求的。

注意，同一站点和同源策略不是同一件事。

### 单进程浏览器开多个页面，渲染线程也只有一个吗？

我们从 IE6 开始讲起，IE6 时代，浏览器是单进程的，所有页面也都是运行在一个主线程中的，当时 IE6 就是这样设计，而且此时的 IE6 是单标签，也就是说一个页面一个窗口。

这时候，国内有很多国产浏览器，都是基于 IE6 来二次开发的，而 IE6 原生架构就是所有页面跑在单线程里面的，意味着，所有的页面都共享着同一套 JavaScript 运行环境，同样，对于存储 Cookie 也都是在一个线程里面操作的。

而且这些国产浏览器由于需要，都采用多标签的形式，所以其中的一个标签页面的卡顿都会影响到整个浏览器。

基于卡顿的原因，国内浏览器就开始尝试支持页面多线程，也就是让部分页面运行在单独的线程之中，运行在单独的线程之中，意味着每个线程拥有单独的 JavaScript 执行环境，和 Cookie 环境，这时候问题就来了：

比如 A 站点页面登陆一个网站，保存了一些 Cookie 数据到磁盘上，再在当前线程环境中保存部分 Session 数据，由于 Session 是不需要保存到硬盘上的，所以 Session 只会保存在当前的线程环境中。这时候再打开另外一个 A 站点的页面，假设这个页面在另外一个线程中里面，那么它首先读取硬盘上的 Cookie 信息，但是，由于 Session 信息是保存在另外一个线程里面的，无法直接读取，这样就要实现一个 Session 同步的问题，由于 IE 并没有源代码，所以实现起来非常空难，国内浏览器花了好长一点时间才解决这个问题的。

Session 问题解决了，但是假死的问题依然有，因为进程内使用了一个窗口，这个窗口是依附到浏览器主窗口之上的，所以他们公用一套消息循环机制，这也就意味这一个窗口如果卡死了。也会导致整个浏览器的卡死。

国产浏览器又出了一招，就是把页面做成一个单独的弹窗，如果这个页面卡死了，就把这个弹窗给隐藏掉。

这里还要提一下为什么 Chrome 中的一个页面假死不会影响到主窗口呢？

这是因为 chrome 输出的实际上图片，然后浏览器端把图片贴到自己的窗口上去，在 Chrome 的渲染进程内，并没有一个渲染窗口，输出的只是图片，如果卡住了，顶多图片不更新了。

国产浏览器这一套技术花了四五年时间，等这套技术差不多成熟时，Chrome 发布了 :(

### Chrome 排版引擎现在是 blink，这一点从哪里可以看到呢？我在 76 版本 Chrome 的 navigator 属性值里只看到了 AppleWebkit，不理解这是为什么？

UserAgent，又称为 UA，UA 是浏览器的身份证，通常，在发送 HTTP 请求时，UA 会附带在 HTTP 的请求头中 user-agent 字段中，这样服务器就会知道浏览器的基础信息，然后服务器会根据不同的 UA 返回不同的页面内容，比如手机上返回手机的样式，PC 就返回 PC 的样式。

你也可以在浏览器的控制台中输入：

```
navigator.userAgent
```

来查看当前浏览器的 UA 信息。

FireFox 中的打印的信息是：

```
"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:68.0) Gecko/20100101 Firefox/68.0"
```

Chrome 中打印的信息是：

```
"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Mobile Safari/537.36"
```

安卓系统中的 Chrome 浏览器：

```
"Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Mobile Safari/537.36"
```

服务器会根据不同的 UA 来针性的设计不同页面，所以当出了一款新浏览器时，他如果使用自己独一无二的 UA，那么之前的很多服务器还需要针对他来做页面适配，这显然是不可能的，比如 Chrome 发布时他会在他的 UA 中使用“Mozilla” ，“AppleWebKit”，等关键字段，用来表示他同时支持 Mozilla 和 AppleWebKit，然后再在最后加上他自己的标示，如 Chrome/xxx。

这就解释了为什么你查看的信息中含有 WebKit 字样。
