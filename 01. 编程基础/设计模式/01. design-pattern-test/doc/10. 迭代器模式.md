## 介绍

- 顺序访问一个集合

- 使用者无需知道集合的内部结构（封装）

## 场景

1. JQuery each

```JavaScript
// 基于 JQuery 
function each(data) {
  // 生成迭代器
  var $data = $(data);
  $data.each(function(key, val) {
    console.log(key, val);
  })
}
```

特点：

  - 顺序遍历有序集合

  - 使用者不必知道集合的内部结构

```JavaScript
class Iterator {
  constructor(container) {
    this.list = container.list;
    this.index = 0
  }
  next() {
    if(this.hasNext()) {
      return this.list[this.index++]
    }
    return null
  }
  hasNext() {
    if(this.index >= this.list.length) {
      return false
    }
    return true
  }
}

class Container {
  constructor(list) {
    this.list = list
  }
  // 生成遍历器
  getIterator() {
    return new Iterator(this)
  }
}

// test
let arr = [0, 1, 2, 3, 4, 5];
let container = new Container(arr);
let iterator = container.getIterator();
while(iterator.hasNext()) {
  console.log(iterator.next());
}
```

2. ES6 Iterator

- ES6 Iterator 为何存在

  * ES6 语法中，有序集合的数据类型已经很多。 
  
  * eg: ``` Array Map Set String TypedArray arguments NodeList ```

  * 需要有一个统一的遍历接口来遍历所有数据类型

  * ``` Object ``` 不是有序集合，可以用 ``` Map ``` 代替

-   ES6 Iterator 是什么

  * 以上数据类型，都有 ``` [Symbol.iterator] ``` 属性

  * 属性值是函数，执行函数返回一个迭代器

  * 这个迭代器就有 next 方法可顺序迭代子元素

  * 可运行 ``` Array.prototype[Symbol.iterator] ``` 来测试

```JavaScript
function each(data) {
  // 生成迭代器
  let iterator = data[Symbol.iterator]();

  let item = {done: false};
  if(!item.done) {
    item = iterator.next();
    if(!item.done) {
      console.log(item.value);
    }
  }
}
```

``` for of ``` 遍历迭代器

```JavaScript
// data 必须是带有遍历器特性的对象 data[Symbol.iterator] 有值
function each(data){
  for(let item of data) {
    console.log(item)
  }
}
```

3. ES6 Iterator & Generator

- Iterator 的价值不限于上述几个类型的遍历

- 还有 Generator 函数的使用

- 即只要返回的数据类型符合 Iterator 接口要求

- 即可使用 Iterator 语法，这就是迭代器模式


## 设计原则验证

- 迭代器对象和目标对象分离

- 迭代器将使用者与目标对象隔离开

- 符合开放封闭原则





