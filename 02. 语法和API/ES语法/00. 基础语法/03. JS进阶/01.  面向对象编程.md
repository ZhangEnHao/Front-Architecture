## 什么是面向对象编程

用 java 中的一句经典语句来说就是：「万事万物皆对象」。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。

> 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

1.  面向对象和面向过程的区别:

面向对象和面向过程并不是完全相对的，也并不是完全独立的。

面向对象和面向过程的主要区别是面向过程主要是以动词为主，解决问题的方式是按照顺序一步一步调用不同的函数。

而面向对象主要是以名词为主，将问题抽象出具体的对象，而这个对象有自己的属性和方法，在解决问题的时候是将不同的对象组合在一起使用。

所以说**面向对象的好处就是可扩展性更强一些，解决了代码重用性的问题。**

- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

- 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

一个很有意思的知乎高票回答:

> 面向对象： 狗.吃(屎)
> 面向过程： 吃.(狗,屎)

2.  五子棋例子

例如五子棋，面向过程的设计思路就是首先分析问题的步骤：

- 1.  开始游戏
- 2.  黑子先走
- 3.  绘制画面
- 4.  判断输赢
- 5.  轮到白子
- 6.  绘制画面
- 7.  判断输赢
- 8.  返回步骤 2

把上面每个步骤用分别的函数来实现，问题就解决了。

而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为

- 1.  黑白双方，这两方的行为是一模一样的
- 2.  棋盘系统，负责绘制画面

第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的 i 变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。

可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了总多步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。

功能上的统一保证了面向对象设计的可扩展性。比如我要加入悔棋的功能，如果要改动面向过程的设计，那么从输入到判断到显示这一连串的步骤都要改动，甚至步骤之间的循序都要进行大规模调整。如果是面向对象的话，只用改动棋盘对象就行了，棋盘系统保存了黑白双方的棋谱，简单回溯就可以了，而显示和规则判断则不用顾及，同时整个对对象功能的调用顺序都没有变化，改动只是局部的。

再比如我要把这个五子棋游戏改为围棋游戏，如果你是面向过程设计，那么五子棋的规则就分布在了你的程序的每一个角落，要改动还不如重写。但是如果你当初就是面向对象的设计，那么你只用改动规则对象就可以了，五子棋和围棋的区别不就是规则吗？（当然棋盘大小好像也不一样，但是你会觉得这是一个难题吗？直接在棋盘对象中进行一番小改动就可以了。）而下棋的大致步骤从面向对象的角度来看没有任何变化。

当然，要达到改动只是局部的需要设计的人有足够的经验，使用对象不能保证你的程序就是面向对象，初学者或者很蹩脚的程序员很可能以面向对象之虚而行面向过程之实，这样设计出来的所谓面向对象的程序很难有良好的可移植性和可扩展性。

## 封装

面向对象有三大特性，封装、继承和多态。对于 ES5 来说，没有 `class` 的概念，并且由于 js 的函数级作用域（在函数内部的变量在函数外访问不到），所以我们就可以模拟 `class` 的概念，在 es5 中，类其实就是保存了一个函数的变量，这个函数有自己的属性和方法。将属性和方法组成一个类的过程就是封装。

> 封装：把客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口。

1.  通过构造函数、原型和 `.` 语法在类上添加属性和方法的区别:

- **构造函数**：通过 `this` 添加的属性和方法总是指向当前对象的，所以在实例化的时候，通过 `this` 添加的属性和方法都会在内存中复制一份，这样就会造成内存的浪费。但是这样创建的好处是即使改变了某一个对象的属性或方法，不会影响其他的对象（因为每一个对象都是复制的一份）。

- **原型**：通过原型继承的方法并不是自身的，我们要在原型链上一层一层的查找，这样创建的好处是只在内存中创建一次，实例化的对象都会指向这个 `prototype` 对象，但是这样做也有弊端，因为实例化的对象的原型都是指向同一内存地址，改动其中的一个对象的属性可能会影响到其他的对象。

- **`.` 语法**：在类的外部通过 `.` 语法创建的属性和方法只会创建一次，但是这样创建的实例化的对象是访问不到的，只能通过类的自身访问。

2.  `JavaScript` 也有 `public` 、`private` 、`protected`

- `public` ：表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用。

- `private` ：表示私有，私有的意思就是除了 `class` 自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。

- `protected`：对于子女、朋友来说，就是 `public` 的，可以自由使用，没有任何限制，而对于其他的外部 `class` ，`protected` 就变成 `private`。

**`js` 中的 `public`**

通过 `new`关键词实例化时，`this` 定义的属性和变量都会被复制一遍，所以通过`this`定义的属性和方法就是公有的。

通过 `prototype` 创建的属性在类的实例化之后类的实例化对象也是可以访问到的，所以也是公有的。

**`js` 中的 `private`**

因为 `JavaScript` 函数级作用域的特性（在函数中定义的属性和方法外界访问不到），所以我们在函数内部直接定义的属性和方法都是私有的。

**`js` 中的 `protected`**

在函数的内部，我们可以通过 `this` 定义的方法访问到一些类的私有属性和方法，在实例化的时候就可以初始化对象的一些属性了。

例子：

```javaScript
var Book = function (id, name, price) {
  //private(在函数内部定义，函数外部访问不到，实例化之后实例化的对象访问不到)
  var num = 1;
  var id = id;
  function checkId() {
      console.log('private')
  }
  //protected(可以访问到函数内部的私有属性和私有方法，在实例化之后就可以对实例化的类进行初始化拿到函数的私有属性)
  this.getName = function () {
      console.log(id)
  }
  this.getPrice = function () {
      console.log(price)
  }

  //public(实例化的之后，实例化的对象就可以访问到了~)
  this.name = name;
  this.copy = function () {
      console.log('this is public')
  }

}

//在Book的原型上添加的方法实例化之后可以被实例化对象继承
Book.prototype.proFunction = function () {
  console.log('this is proFunction')
}

//在函数外部通过.语法创建的属性和方法，只能通过该类访问，实例化对象访问不到
Book.setTime = function () {
  console.log('this is new time')
}
var book1 = new Book('111','悲惨世界','$99')
book1.getName();        // 111 getName是protected，可以访问到类的私有属性，所以实例化之后也可以访问到函数的私有属性
book1.checkId();        //报错book1.checkId is not a function
console.log(book1.id)   // undefined id是在函数内部通过定义的，是私有属性，所以实例化对象访问不到
console.log(book1.name) //name 是通过this创建的，所以在实例化的时候会在book1中复制一遍name属性，所以可以访问到
book1.copy()            //this is public
book1.proFunction();    //this is proFunction
Book.setTime();         //this is new time
book1.setTime();        //报错book1.setTime is not a function
```

## 继承

> 继承：子类可以使用父类的所有功能，并且对这些功能进行扩展。继承的过程，就是从一般到特殊的过程。
