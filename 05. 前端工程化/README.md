# 什么是前端工程化

工程化：所有能降低成本，并且能提高效率的事情。

前端工程化就是通过各种工具和技术，提升前端开发效率的过程。一切以提高性能、稳定性、可用性、可维护性等目标的工作统称。

- 前端工程化的内容：各种工具和技术

- 前端工程化的作用： 通过使用工具，提升开发效率

学习前端工程化，就是学习使用各种工具，解决前端开发中的各种问题。

- 压缩工具：项目上线前，压缩代码

- 转换工具：对 `ES6+` 或 `CSS3` 新特性进行转换

- 编译工具：对 `Less` 等 `CSS` 的预编译语言进行编译转换

- 格式化工具：格式化代码

- 自动化工具：自动化测试、自动化部署

- 脚手架工具

- ...

eg: [前端工程化内容](../images/FrontEngineerInfo.jpg)

⚠️ 注意：工程化 != 工具，工程化是概念、思想、工作方式。工程化及前端的繁荣归功于 `Node` 这一基石。

## 为什么需要工程化

1. 现在的前端 “太大”、“太复杂”。

2. 不再是后端的附属品

作为前端架构的一部分，工程化是个永恒的话题，我们之所以老生常谈这个事情，核心原因在于浏览器这个环境所支持的三种语言没有在语言层面提供统一的模块化支持，这使得大家都在考虑如何添加这些模块特性，更好的支持好开发。而之所以模块本身非常重要，是因为我们知道分而治之的道理。
以上这段话怎么理解呢，想象一下你所接触的最基本语言 HTML、CSS、JS，对于这三种浏览器端标准语言在早前是不支持模块引入的，如果你想对 JS 进行模块拆分，你就得依靠 HTML 来串起来执行，当然 CSS 是具备这个能力的，HTML 在现在的标准中也逐步有了这样的能力。HTML、CSS、JS 组合式的出现，这又让我们了解到，我们需要定义一类 UI 模块，这里通常的叫法是 UI 组件。它们包含了 HTML、CSS、JS，我们通过工程化的手段来达到组件的工程化支持。现在的浏览器已经逐步支持 Web Component 来逐步磨平这些个不足。

为了实现分而治之，我们不得不实现一套组件化体系，这套体系一方面约束开发，一方面完美地演绎分而治之的精髓。组件化体系解决了开发过程中复用的问题，当然得想办法解决运行的问题。比如当我们通过组件的方式去完成一个站点的拆分工作，会发现拆分后的组件很多，达到了分而治之的目的但同时给运行带来了不少的麻烦，这个麻烦我们是需要去解决的。所以我们的工程化体系里面有了打包(package)这个名词，这个名词几乎是我们工程化体系中无法抹去的一个话题，也同样是性能优化体系里面一个非常重要的手段。

在组件化的体系里面，我们可以回想一下静态编译语言或者支持模块化的语言对于模块的一个特性，比如继承、比如扩展、再比如依赖。同样我们构建的组件化体系中统一要解决这些问题。当你在开发静态编程语言 c 语言的时候，在编译阶段会有依赖错误产生，这时候你可能非常好解决这个问题，你可以按照错误去解决。另一个比较难以解决的问题是运行时发现有依赖的基础库错误，这时候就不好解决了。同样在前端的组件化体系中也同样有这样的问题。

解决依赖是个非常麻烦的事情，一般我们会在构建编译的阶段去搞定这个事情，如果静态编译想搞定这个事情需要有一套可识别的标志。这就是刚才提到的组件化体系里面对于组件的引用的设定更准确一些就叫语法（require、define、import），这也是组件化规范的一部分（比如 CommonJS、AMD、CMD、UMD），在当下 ES6 默认支持。一般都会使用路径引入模块。构建时通过分析这些语法，来获得依赖关系。依赖关系有两个用途，一方面是在合并打包的时候作为参考，另一方面在浏览器端运行时提前去加载依赖；为了解决依赖问题，有很多名词经常出现，比如依赖前置。

> 每个构建工具在解决依赖这块做法是不太一样的，有些是从根节点搜索一棵树，有些是先分析出依赖树，最后再去根据收集到的依赖决策打包。实现方式有正则方式、也有 AST 方式，当然这些都大同小异，如果感兴趣也可以自己创造一种新的方式。

加载组件以及组件的依赖，在浏览器执行阶段可以有两种方式，一种是同步加载，对于同步加载的情况一般的做法是在 HTML 上 script 标签进行外链，另外一种方式是通过 JS 动态生成 script 节点来外链或者直接 Ajax 或者 Fetch 请求代码片段再执行。这种方式也同样适用于 CSS。加载工作主要是 Loader 来完成的，所以在组件化体系中有个 JS Loader 的概念。require.js、seajs 等都有这方面的支持。再往大里面延展 Loader 的功能，解决加载、处理依赖、保证执行、保证作用域、保证各种方式的执行代码的都由一个 JS 框架完成。

分治是为了更好的开发、维护、调试，其最核心优化的是研发的效率，合并（打包）最核心优化的是浏览器端运行的效率。所以，我们工程化其中一个核心的目标就是优化效率。

> 开发阶段，我们需要的是开发体验的提升，希望用抽象的思维去看待一切，绝不去浪费时间在重复的事情上。这样的情况下孕育了各种各样的工具。比如脚手架、模拟服务、LiveReload、HMR 等等。

我们希望覆盖整个研发流程，从方方面面进行效率的提升。这就是工具这个方向的使命。

站在浏览器的视角，运行快速、准确是最终我们要达到的目标。为了这个目标，根据网页的特性，我们需要优化整个链路，包括资源的加载、代码的运行、浏览器渲染的研究、数据的获取等等。积攒了非常多的经验后，把这些经验融合到我们的工程化体系里面，把这些优化在业务开发中不可见，按照某种方式去做，然后就可以获取到最佳性能，而不需要做额外的工作。这就是架构本身的魅力，做到这一点需要有规范。

站在研发的视角，开发快、易于调试、快速上线这些是我们的目标，对于这些目标，我们同样需要有一定的规范。规范我们代码如何写更易于维护，规范我们用什么语法更快速的能够开发。

不管是组件化体系、运行时效率、研发效率都需要规范，这些规范整体归纳为我们的研发规范体系；除了规范体系，还有更多的基础设施围绕着效率展开，比如更好写的语言、更高纬度的抽象、更高效的框架等等。

> 开发的场景里面，CSS 不好写，我们就有了 Sass；JS 弱类型，我们就有了 Typescript；另外为了开发的更高效，我们有了一堆的框架，React、Vue、Angular 等等。

我们围绕研发、浏览器两个视角不停的在构建我们的工程体系，希望于把一些繁杂的事情化简、把一些固化的优化对于研发透明。

固化的方式是有可能限制创造的，所以为了达到激发创造的可能，松耦合的工程架构体系才更适用。松耦合的工程体系会造成更多的个性化，个性化就可能降低效率。所以做工程也是一个反复折中的过程，无法一蹴而就，一劳永逸。

## 工程化要解决的问题

1. 提高前端开发效率

- 扩展 `javaScript` `css` `html` 本身的语言能力
- 解决重复性工作
- 模块化、组件化
- 解决功能复用和变更问题
- 解决开发和产品环境差异问题
- 解决开发流程问题

2. 进行高效的多人协作

3. 保证项目的可维护性

4. 提高项目的开发质量

[精读《插件化思维》](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/53.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%8F%92%E4%BB%B6%E5%8C%96%E6%80%9D%E7%BB%B4%E3%80%8B.md)

[精读《新一代前端构建工具对比》](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/195.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%96%B0%E4%B8%80%E4%BB%A3%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94%E3%80%8B.md)

[精读《如何编译前端项目与组件》](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/89.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%8B.md)

[senntyou](https://www.jianshu.com/u/26ce9d256997)

[前端工程之模块化](http://fex.baidu.com/blog/2014/03/fis-module/)

[fouber/blog](https://github.com/fouber/blog)

[Tecvan](https://juejin.cn/user/1820446985555544/posts)

[前端编译和工程化](https://juejin.cn/column/6992030342987120677)

[你真的了解package.json吗？来看看吧，这可能是最全的package解析](https://juejin.cn/post/6987179395714646024)

[《大前端进阶 工程化》系列 P6必备脚手架/CI构建能力（上）](https://mp.weixin.qq.com/s/4HeDZW5ND6-7wHny0J1TQw)

[《大前端进阶 Node.js》系列 P6必备脚手架/CI构建能力（下）](https://mp.weixin.qq.com/s/vgcxF2MSVtbf-phfHI6GHw)

[前端工程化：如何使用monorepo进行多项目的高效管理](https://juejin.cn/post/7043990636751503390)

[Changesets: 流行的 Monorepo 场景发包工具](https://mp.weixin.qq.com/s/QKqaO3U1gzwWb2sDiF4cLQ)
