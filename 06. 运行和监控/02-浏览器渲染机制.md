## 前言

**渲染机制**包括的内容：

- 什么是 DOCTYPE 及作用

- 浏览器渲染过程。面试经常会问：在浏览器中输入 url，发生了哪些事情。其中有一部就是浏览器的渲染过程。

- Reflow：重排。面试官问完了渲染机制，一般会紧接着问重排 Reflow，你可千万别说你没听过。

- Repaint：重绘

- Layout：布局。这里的 Layout 指的是浏览器的 Layout。

## 什么是 DOCTYPE 及作用

### 定义

**DTD**（Document Type Definition）：文档类型定义。

是一系列的语法规则，用来定义 XML 或者 (X)HTML 文件类型。**浏览器会使用 DTD 来判断文本类型**，决定使用何种协议来解析，以及切换浏览器模式。（说白了就是：DTD 就是告诉浏览器，我是什么文档类型，你要用什么协议来解析我）

**DOCTYPE**：用来声明 DTD 规范。

一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出现一些差错。（说白了，DOCTYPE 就是用来声明 DTD 的）

### 常见的 DOCTYPE 声明有几种

> 面试官紧接着会问，常见的 DOCTYPE 有哪些，以及 HTML5 的 DOCTYPE 怎么写。

1. **HTML 4.01 Strict**：（严格的）

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

PS：该 DTD 包含所有的 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font、u 下划线等，这些是被废弃了的）。

2. **HTML 4.01 Transitional**：（传统的）

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
```

PS：该 DTD 包含所有的 HTML 元素和属性，但包括展示性的和弃用的元素（比如 font、u 下划线等）。

3. HTML 5：

```html
<!DOCTYPE html>
```

**总结：**

面试时，不会让你写出 HTML 4.01 的写法，因为大家都记不住。但是要记住 HTML 5 的写法，别看它简单，知道的人还真不多。

面试时，可以这样回答： HTML 4.01 中有两种写法，一种是严格的，一种是传统的；并且答出二者的区别。 HTML 5 的写法是`<!DOCTYPE html>`。

## 浏览器的渲染过程

### 渲染树

![](./images/20210118-2005.png)

> 上方图片的来源：[Google 官方 | 渲染树构建、布局及绘制](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)

**渲染树**包含了网页中有哪些节点、节点的从属关系、以及节点的 CSS 样式（大小、颜色等）。

浏览器下载完 html 文档之后，第一步是先将其解析成文本。而 html 标签是由一对一对的尖括号表述的，可以被浏览器解析为有含义的标记。这些标记被翻译成节点对象，存放到链型数据结构中。这些节点被称之为**DOM 对象**，这个链型数据结构就是**渲染树**。

### 渲染过程（重要）

浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是 JS 引擎。渲染引擎在不同的浏览器中也不是都相同的。目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。这里面大家最耳熟能详的可能就是 Webkit 内核了，Webkit 内核是当下浏览器世界真正的霸主。

本文我们就以 Webkit 为例，对现代浏览器的渲染过程进行一个深度的剖析。

从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：

- DNS 查询
- TCP 连接
- HTTP 请求即响应
- 服务器响应
- 客户端渲染

### 页面加载过程(客户端渲染)

- 浏览器根据 DNS 服务器得到域名的 IP 地址；
- 向这个 IP 的机器发送 HTTP 请求；
- 服务器收到、处理并返回 HTTP 请求；
- 浏览器得到返回内容。(HTML)

### 浏览器渲染过程

浏览器渲染过程大体分为如下几部分：

1. 处理 HTML(HTML/SVG/XHTML) 并构建 DOM 树(DOM Tree)。

2. 处理 CSS 构建 CSSOM 树(CSS Rule Tree)。

3. 遇到 `<script>` 则暂停渲染，优化加载并执行 JS 代码， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。

4. 将 DOM 树与 CSSOM 树合并成一个渲染树(Rendering Tree)。

   - Rendering Tree 渲染树并不等同于 DOM 树，渲染树只会包括需要显示的节点和这些节点的样式信息。如果某个节点是 display: none 的，那么就不会在渲染树中显示。
   - CSS 的 Rule Tree 主要是为了完成匹配并把 CSS Rule 附加上 Rendering Tree 上的每个 Element（也就是每个 Frame）。

5. 根据渲染树来布局，计算每个节点(Frame)的位置(layout 和 reflow 过程)。

6. 调用 GPU 绘制，合成图层，显示在屏幕上。

![](./images/20180310_1257.png)

渲染过程中，涉及到以下几个概念：

- DOM 树（DOM Tree）：浏览器将 HTML 标签解析成树形的数据结构。DOM 树包含了有哪些节点，以及节点之间的从属关系（嵌套关系）。

- CSSOM（CSS Rule Tree）：浏览器将 CSS 解析成树形的数据结构。CSSOM 包含了节点的 CSS 样式（大小、颜色等）。

- 渲染树（Render Tree）: DOM 树与 CSSOM 树**合并**后形成渲染树。渲染树只包含渲染网页所需的节点（但并不知道位置）。

- 布局（Layout）: 计算出每个节点在屏幕中的**位置和大小**。

- 绘制（Painting）：按照算出来的规则，通过显卡，把内容画出来。

- composite：合成。浏览器在绘制的时候，一开始不会把所有的内容都画在同一层上。需要把这些内容画在不同的曾上，最终合并到一起，并显示在屏幕上。

### 浏览器如果渲染过程中遇到 JS 文件怎么处理？

渲染过程中，如果遇到 `<script>` 就停止渲染，执行 JS 代码。因为浏览器有 GUI 渲染线程与 JS 引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript 的加载、解析与执行会阻塞 DOM 的构建，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停构建 DOM，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复 DOM 构建。

也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性，`<script>` 标签打开 defer 或 async 属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。。

JS 文件不只是阻塞 DOM 的构建，它会导致 CSSOM 也阻塞 DOM 的构建。

原本 DOM 和 CSSOM 的构建是互不影响，井水不犯河水，但是一旦引入了 JavaScript，CSSOM 也开始阻塞 DOM 的构建，只有 CSSOM 构建完毕后，DOM 再恢复 DOM 构建。

这是因为 JavaScript 不只是可以改 DOM，它还可以更改样式，也就是它可以更改 CSSOM。因为不完整的 CSSOM 是无法使用的，如果 JavaScript 想访问 CSSOM 并更改它，那么在执行 JavaScript 时，必须要能拿到完整的 CSSOM。所以就导致了一个现象，如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后在继续构建 DOM。

### async 和 defer 的作用和区别

1. `<script src="script.js"></script>`

没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。

2. `<script async src="script.js"></script>` (异步下载 下载完就执行)

async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。

3. `<script defer src="script.js"></script>` (延迟执行 渲染完再执行)

defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。

defer 与相比普通 script，有两点区别：

- 载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。

- 如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。

### Load 和 DOMContentLoaded 区别

- Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。
- DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。

### 复合线程

复合线程会将页面拆分图层进行绘制再进行复合。

### 图层

一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。

通过以下几个常用属性可以生成新图层

- 3D 变换：translate3d、translateZ
- will-change
- video、iframe 标签
- 通过动画实现的 opacity 动画转换
- position: fixed

### 关键渲染路径

说到渲染，就不得不提到“关键渲染路径”，它描述的是渲染从触发到绘制的过程。浏览器渲染经历了五个阶段：

> JavaScript/CSS --> Style --> Layout --> Paint --> Composite

![](./images/20210118-1950.jpg)

> 上方图片的来源：<https://developers.google.com/web/fundamentals/performance/rendering>

关键渲染路径描述的是渲染从触发到绘制的全过程，一共经历了五个阶段：

（1）**触发视觉的变化：**通过 JS、CSS 代码来**触发**页面上的视觉变化。比如通过 jQuery 添加节点、通过 CSS 添加动画，都可以触发视觉上的变化。

（2）Style：浏览器对样式进行计算。匹配选择器，计算哪些 CSS 受到了影响。

（3）layout：同上一段。

（4）painting：同上一段。

（5）conmposite：同上一段。

理论上，上面的五个步骤都是必须要经历的。布局和绘制是关键渲染路径中，最重要、开销最高的两个步骤。

但是，有些样式并不会影响布局，也不会影响绘制。所以，浏览器对这方面的性能进行了优化，并不一定要经历布局和绘制这两个过程。这就需要我们先了解一下「重排」和「重绘」这两个概念。详见下一段。

## 重绘（Repaint）和回流（Reflow）

- 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘

对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。

- 回流是布局或者几何属性需要改变就称为回流。

对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来，这个过程就是回流（也叫重排）。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。

1. 常见引起回流属性和方法

任何会改变元素几何信息 (元素的位置和尺寸大小) 的操作，都会触发回流，

- 添加或者删除 可见的 DOM 元素 / 样式；

- 元素尺寸改变 —— 边距、填充、边框、宽度和高度；

- 内容变化，比如用户在 input 框中输入文字；

- 修改浏览器窗口尺寸时（即 resize 事件发生时，移动端没有这个问题），或是滚动的时候，**有可能**会触发（具体要看浏览器的规则）；

- 计算 offsetWidth 和 offsetHeight 属性；

- 设置 style 属性的值；

- 改变 window 大小 / 字体 / 文字；

- 定位或者浮动

- 修改网页的默认字体时（这个很消耗性能）；

- display: none；

2. 常见引起重绘属性和方法

- color

- border-style

- visibility

- background

- outline

3. 减少重绘和回流

- 使用 translate 替代 top
- 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）；
- 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来；
- 不要把节点的属性值放在一个循环里当成循环里的变量。可以使用 [FastDom](https://github.com/wilsonpage/fastdom) 批量对 DOM 进行读写操作。

```javaScript
  for (let i = 0; i < 1000; i++) {
    // 获取 offsetTop 会导致回流，因为需要去获取正确的值
    console.log(document.querySelector('.test').style.offsetTop)
  }
```

- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局；
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame；
- CSS 选择符从右往左匹配查找，避免节点层级过多, DOM 深度过深；
- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。

## 性能优化策略

基于上面介绍的浏览器渲染原理，DOM 和 CSSOM 结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。

- JS 优化： <script> 标签加上 defer 属性 和 async 属性 用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。
- defer 属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。
- async 属性： HTML5 新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。
- CSS 优化： <link> 标签的 rel 属性 中的属性值设置为 preload 能够让你在你的 HTML 页面中可以指明哪些资源是在页面加载完成后即刻需要的，最优的配置加载顺序，提高渲染性能。

## 总结

1. 浏览器工作流程：构建 DOM -> 构建 CSSOM -> 构建渲染树 -> 布局 -> 绘制。

2. CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。

3. 通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新 DOM 构建。

[浏览器的渲染原理简介](https://coolshell.cn/articles/9666.html)

[浏览器的回流与重绘 (Reflow & Repaint)](https://juejin.cn/post/6844903569087266823)

[浏览器渲染原理及流程](http://www.cnblogs.com/slly/p/6640761.html)

[如何减少浏览器 repaint 和 reflow ?](http://blog.csdn.net/liaozhongping/article/details/47057889)
