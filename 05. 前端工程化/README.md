## 什么是前端工程化

前端工程化，就是**降本提效**的体现。

广义上，前端工程化包含一切以**降低成本、提高效率、保障质量**为目的的手段。

狭义上，前端工程化是指围绕代码处理的一系列工具链，他们把代码当作字符串处理，并不运行代码，包括编译构建、静态分析、格式化、CI/CD 等等。

**通过一系列的规范、流程、工具达到研发提效、自动化、保障质量、服务稳定、预警监控等。**

前端工程化就是通过各种工具和技术，提升前端开发效率的过程。一切以提高性能、稳定性、可用性、可维护性等目标的工作统称。

⚠️ 注意：工程化 != 工具，工程化是概念、思想、工作方式。工程化及前端的繁荣归功于 `Node` 这一基石。

## 为什么需要工程化

项目发展过程中，随着项目成员增加，系统复杂度上升，会引发如下问题：

1. 系统质量的下降

项目开发人员频繁变更，系统功能新增和迭代，都会导致缺陷的增加，需要通过系统上线前的质量监测来尽早发现问题。

为降低系统复杂度，到了一定阶段，对系统进行局部或者整体的架构调整，引入新技术，但也可能引发新问题：

- 部分功能无法与新技术兼容。

- 影响面广，可能有缺陷无法及时发现。

2. 开发效率的下降

系统上线之后，开发工作内容变得复杂，需要关注的事情更多，不停切换不同工作内容，容易遗漏工作步骤，导致流程出现问题，导致系统质量不稳定，技术债务更多，团队开发效率下降。

前端工程化，就是要解决如上两大类问题，提升系统质量和开发效率，提升团队的人工投入产出比。

## 如何进行前端工程化

### 系统质量

#### 设计前端项目

设计前端项目时，需明确技术选型的影响因素（具体如下），再具体做对应决策

1. 项目规模、功能交互

影响框架、工具选型，可考虑使用开源/现有框架，目前三大主流框架包含 Angular、Vue、React

2. 用户体系

影响兼容性的倾向，比如 APP 主要群体是老年人，需要考虑旧版本手机的兼容性

3. 多人协作、团队规模

考虑完善规范，尽量使用工具保证规范进行

- 使用一致的代码开发规范

  - 使用 Eslint 监测代码规范

  - 使用 Prettier 自动化格式代码

  - 使用 Git Commit Hooks 拒绝不符合规范的代码提交

  - 使用流水线检测出不规范代码，并拒绝合入主干分支，拒绝进入发布流程

- 合入代码前，进行 Code Review，遇到分歧时，可通过投票

- 制定合适的代码流程规范

  - 关联需求单/bug 单的分支命名

  - 检查代码是否符合规范、进行 Code Review

  - 自动化构建和测试代码

  - 灰度发布代码

- 通过自动化工具确保流程正常进行，比如使用 CI/CD

4. 团队技术栈

- 考虑团队现有的技术栈、团队成员对框架/工具的熟悉程度，团队成员倾向的框架/工具

- 使用团队成员比较熟悉的技术栈，可减少开发问题，提升开发效率

- 针对新技术方案，则可通过成员讨论和投票

#### 搭建前端监控体系

搭建前端监控体系是为了及时发现问题，快速定位并解决问题，监控页面整体访问情况包括常见的 PV、UV、用户操作行为，监控页面性能

##### 1. 前端监控需关注的数据

- 系统的生命周期数据，包括页面加载的关键时间点，比如页面打开、更新、关闭等，获取方式：

  - `PerformanceTiming` 属性可获取用于页面跳转、加载等数据

  - `document.DOMContentLoader、document.readystatechange`，可获取页面加载数据

  - Vue 的生命周期函数也可进行数据收集

  - `MutationObserver` 接口可结合 `performance.now()` 获取到具体的时间

- HTTP 测速数据

`PerformanceTiming` 属性也可获取 HTTP 请求相关数据，比如 HTTP 跳转开始/结束，域名查询开始/结束等时间戳，用于观察后端服务稳定情况、可优化空间

- 系统异常数据

包括逻辑错误、代码健壮性、网络错误、系统错误、页面内容异常等数据。

前 4 种的异常数据，可用 `window.onerror`、`document.addEvenetListener(error)`、`XMLHttpRequest status` 等方法拦截，第 5 种异常可通过回归测试、UI 界面测试等方式获取

- 用户行为数据

包括页面浏览点击量、页面停留时间、访问入口、用户操作、用户链路数据，用于监控页面功能是否正常、分析用户行为，定位问题，以便更好地调整产品功能。

可通过 DOM 元素的时间监听、页面加载情况。

- 用户日志

使用用户日志定位系统异常信息

自动打印日志的方式：添加装饰器、对类方法进行劫持

存放系统输出日志：上报到服务器和本地存储两种方式配合使用

##### 2. 数据采集

- 数据埋点

| 前端常见埋点方案 | 使用方式   | 自定义数据 | 更新代价     | 使用成本 |
| :--------------- | :--------- | :--------- | :----------- | :------- |
| 代码埋点         | 手动编码   | 可自定义   | 需要版本更新 | 高       |
| 可视化埋点       | 可视化圈选 | 较难自定义 | 需要下发配置 | 中       |
| 无痕埋点         | 嵌入 SDK   | 难以自定义 | 不需要       | 低       |

- 数据上报

  - 定期/定量上报：收集数据到一定数量之后，再一次性打包，或者按照一定的时间间隔打包上传

  - 关键生命周期上报

  - 用户主动提交：引导用户主动上传异常和使用体验问题

##### 3. 搭建可视化管理端

- 日常监控：配置告警阈值，结合邮件、机器人推送，发现问题

- 版本发布和灰度：关注错误告警、全版本监控观察、分版本监控观察，出现数据异常，配合告警渠道通知负责人

#### 性能优化

##### 常见的性能优化方案

###### 时间角度优化：减少耗时

1. 网络请求优化

- 减少 DNS 查询时间。比如使用浏览器、计算机、服务器等 DNS 缓存。

- 合理使用 CDN。

- 缓存请求资源。比如使用浏览器、HTTP、后台等缓存。

- 移除无用代码。比如 Tree-shaking、代码分割、移除无用依赖项。

- 合理拆分请求资源。

- 压缩资源。

- 使用 HTTP2、HTTP3。

- 优化请求。比如合并多个请求、对请求进行域名拆分。

2. 性能和渲染耗时优化

- 分片、分屏加载页面。

- 优化资源加载的顺序和粒度，仅加载需要的资源，通过异步加载方式加载剩余资源。

- 使用差异化服务。比如读写分离，按需加载需要的模块。

- 使用服务端支出渲染。

- 使用秒看技术，通过预览方式提前将页面内容提供给用户。

- 配合客户端进行资源预请求和预加载，比如使用预热 Web 容器。

- 配合客户端将资源和数据进行离线，用于下次页面的快速加载。

3. 渲染过程优化

- 使用资源预加载，空闲时间提前获取并加载可能用到的资源。

- 减少 DOM 数量，减少/合并 DOM 操作。

- 合理使用浏览器 GPU 合成。

- 使用离屏渲染，在页面不可见的地方提前进行渲染。比如 Canvas 渲染。

- 将页面渲染帧率保持在 60 FPS 左右。

- 使用页面过渡动画。比如加载中，给用户反馈。

4. 计算/逻辑运算提速

- 将 JS 大任务进行拆分和并行计算。比如 Web Worker。

- 使用运行效率更高的方式。比如使用 Webassembly。

- 提前计算过程。比如使用 AOT。

- 使用更优的算法/存储结构，比如 VSCode 使用红黑树优化文本缓存区计算。

- 缓存计算结果。

###### 空间角度优化：降低资源占有

1. 合理使用缓存，不滥用缓存资源，既是清理缓存。

2. 使用数据结构享元的方式，减少对象创建。

3. 避免内存泄漏。比如避免全局变量的使用，及时解除引用等等。

4. 避免复杂/异常的递归调用。

##### 如何在项目中进行性能优化

1. 确定优化的目标和预期

- 明确性能数据

  - 网络资源请求时间

  - Time To Start Render(TTSR)：浏览器开始渲染的时间

  - Dom Ready：页面解析完成的时间

  - Time To Interact(TTI))：页面可交互时间

  - Total Blocking Time (TBT)：总阻塞时间，代表页面处于不可交互状态的耗时

  - First Input Delay(FID)：从用户首次交互，到浏览器响应的时间

- 对性能数据进行目标和预期的确定：比如对比原先数据优化到多少比例，分析竞品确定目标

2. 确定技术方案

- 技术方案调研

  - 分析项目背景，挖掘项目痛点

  - 分析项目现状

  - 调研业界方案

- 技术方案设计，方案选型/对比

  - 梳理项目现状：比如项目规模大，开发多

  - 梳理项目痛点：比如不同模块变更导致性能下降，问题往往在测试时才发现

  - 调研性能分析方案：通过 Performace 火焰图、Lighthouse、Chrome Devtools Protocol 等工具

  - 根据对比和分析确定最优方案，并跟领导解释

### 开发效率

主要分析项目在开发过程中的效率提升点，学会如何在未来的项目中选择和搭建最适合自己的开发工具

#### 开发构建

##### 热更新

当本地代码文件发生变化时，浏览器自动更新页面内容

1. webpack 热更新配置

- 手动配置

- `watch` 模式，配置 `watch:true`，无需手动执行打包构建，但需要手动刷新浏览器

- Live Reload 模式，配置 `contentBase：文件路径`，`open：true`，浏览器内容自动更新，但页面状态无法保存

- Hot Module Replacement（HMR，模块热替换），配置 `hot: true`

模块热替换插件实现热替换功能，主要依赖 `module.hot` 的属性

- `module.hot.accept(模块名称，回调方法)`：当依赖模块发生更新时，执行回调方法

- `module.hot.dispose(回调方法)`：当代码上下文的模块被移除时，执行回调方法

2. webpack 热更新原理

- 监控源代码文件内容的变更

- 进行服务端和网页端的 socket 通信

- 进行模块解析和替换，依次执行匹配 `module.hot` 对应 `moduleId` 的回调函数，进行热替换，若未命中，则触发重新加载

##### sourceMap

在调试时将产物代码显示回源代码

sourceMap 的基本原理：在编译处理过程中，产物代码在被转换时，与源码生成了映射关系表，利用这映射表来实现调试时的显示与定位源代码功能。

在开发环境中，通常关注构建速度快、质量高，以便于提升开发效率，不关注生成文件的大小和访问方式，建议使用 `cheap-module-source-map`，可以在浏览器下看到正确的错误提示。

在生产环境为了防止源码泄露，建议使用 `false`，不使用 `source-map`。

#### Mock 工具

模拟数据的工具，用于测试或者预先联调

1. 选择 Mock 方案需注重

- 仿真度：尽可能与后端实际提供接口的各方面保持一致

- 易用性：需要具备将接口文档自动转换为 Mock 接口的能力

- 灵活性：根据不同条件下返回值的差异做不同的交互处理

2. 四种主流 Mock 工具

- Mock.js：Mock 数据生成工具

  - 提供生成模拟数据的规范和方法

  - Ajax 请求拦截：拦截特定 url 的请求，直接将模拟数据作为响应值返回

  - 数据验证：验证指定数据和数据模板是否匹配

  - 模板导出：将 Mock.js 风格的数据模板转换为 JSONSchema

- Faker.js：Mock 数据生成工具

  - 提供指定类型的随机数据

  - 在 API 的使用方面较直观

  - 支持多种语言的本地化包

- YApi：开发、产品、测试人员共同使用的接口管理服务

  - 支持接口的定义、修改、运行、集合测试等

  - 提供 Mock 服务，以定义的接口可以通过服务直接获取 Mock 数据

  - 支持 Swagger 多种接口描述的数据导入与导出

  - 支持部署到内网服务以及自定义插件

- Apifox：桌面应用类的接口管理工具

  - 支持接口调试工具 Postman 的特色功能

  - 对同一个接口支持多种用例管理

  - 支持自定义期望数据，支持自定义占位符规则等

  - 支持生成自动业务代码和接口请求代码，支持自定义代码模板等

#### 编码效率工具

##### 使用预处理语言和预处理器

1. CSS 的主流预处理器：Less/Sass/Stylus

- 使用人数从多到少排序：Sass > Less> Stylus

- Less 缺少自定义函数的功能，Stylus 提供了超过 60 个内建函数

- Sass 支持 .scss 与 .sass 两种文件格式，Less 的整体语法更接近 .scss，Stylus 则同时支持类似 .sass 的精简语法和普通 CSS 语法

- sass-loader 和 stylus-loader 安装时都需要同时安装独立编译包 Sass / node-sass 和 Stylus，而 less-loader 则不强制要求

2. HTML 模板的主流预处理器：Pug

功能：简化标签书写、支持迭代、条件、拓展、包含、混合等逻辑功能

Vue 内置 pug-loader 作为预处理器，React 需要通过 babel 插件获得支持

##### 使用代码生成工具

1. Snippet

开发过程中用户在 IDE 使用的可复用代码片段

可编写自身开发常用的个性预设片段，提升编码效率

可以在团队中共享和共同维护，提升团队效率

2. Emmet

面向各类编辑器的 Web 开发插件，用于快速编写和编辑结构化的代码

支持功能：

缩写代码块

CSS 缩写

自定义片段

#### 云开发

将开发环境托管至云服务，开发服务器变更为云服务

1. 优点：

- 集成开发环境所需基础设施，提升开发环境准备的效率

- 流程简化，易上手

- 统一流程规范、开发工具共享

- 提升资源利用率，降低硬件资产成本

2. 注意点：

- 代码安全问题：设置访问权限，首选支持内部部署的云服务或者搭建自己维护的云服务

- 服务搭建与维护：考虑成本

- 服务降级与备份：考虑当系统异常时的策略

### 构建效率

主要分析影响 webpack 构建时间的关键因素，并分析对应的解决方案和工具

#### webpack 编译阶段提效

[前端进阶必备 - 前端工程化](https://mp.weixin.qq.com/s/Nmj1wbf2UfVjKUdvAYGvhw)

[让自动化工作流解放你的双手](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247484480&idx=1&sn=b871c9a3d5e671dbc73586a8940fd4c2&chksm=fa2be4a9cd5c6dbfa01241b7cd3c90f10c6a268f740853aeeb57d4d265d61c09fd2dec510047&scene=126&&sessionid=1664420293#rd)

[大厂前端如何基于 GitLab 进行自动化构建及发布](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247484766&idx=1&sn=ff80bdee71e16a919adb0b2565d6e3dc&chksm=fa2be5b7cd5c6ca1421783f036095dad953ce32050c021f3fe88aeb76cbb9a1235a35f682d44&scene=126&&sessionid=1664420289#rd)

[起底阿里完整前端技术体系](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247484768&idx=1&sn=c361c4898f959c7398e19895d4901e7a&chksm=fa2be589cd5c6c9ff090c2a910ed299d9969bb38f3c0adee6405b01dc5ed86994bfccdec54bb&scene=126&&sessionid=1664420289#rd)

[起底腾讯完整前端技术体系](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247484860&idx=1&sn=7db80864bf851f733e90f0e334fde46a&chksm=fa2be555cd5c6c4384220883144ba221ab772593e88538f8441301def95e7345b849d3312ae8&scene=126&&sessionid=1664420287#rd)

[前端基础建设如何做？尤其对于身处小团队的开发者](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247485419&idx=1&sn=320a215bdc158fbbaafe67d516f931b2&chksm=fa2be702cd5c6e1409edc3bcfbe5ce745df9ee1f7e31c96fe3cc8b6445405ead26b3de419f10&scene=126&&sessionid=1664420280#rd)

[论前端技术和前端工程之辩](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247487888&idx=2&sn=8c4f036953ee4e8ea7bc5dd02b92400b&chksm=fa2bf179cd5c786ffce1c982b944cf9e15f0d39485d6a576f4fe173a76470d7b06b6afd680e6&scene=126&&sessionid=1664420258#rd)

[一键格式化代码带来的快感 | 你还在为每个项目配置 Stylelint 和 Eslint 吗](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247488077&idx=1&sn=9fd0fecc37f6d2a421b5faf677294e17&chksm=fa2bf2a4cd5c7bb201cfe64db66f7efbac7a3a14691cbe64077a1291e9c949ef34d89b7e688e&scene=126&&sessionid=1664519640#rd)

```markdown
作为前端架构的一部分，工程化是个永恒的话题，我们之所以老生常谈这个事情，核心原因在于浏览器这个环境所支持的三种语言没有在语言层面提供统一的模块化支持，这使得大家都在考虑如何添加这些模块特性，更好的支持好开发。而之所以模块本身非常重要，是因为我们知道分而治之的道理。
以上这段话怎么理解呢，想象一下你所接触的最基本语言 HTML、CSS、JS，对于这三种浏览器端标准语言在早前是不支持模块引入的，如果你想对 JS 进行模块拆分，你就得依靠 HTML 来串起来执行，当然 CSS 是具备这个能力的，HTML 在现在的标准中也逐步有了这样的能力。HTML、CSS、JS 组合式的出现，这又让我们了解到，我们需要定义一类 UI 模块，这里通常的叫法是 UI 组件。它们包含了 HTML、CSS、JS，我们通过工程化的手段来达到组件的工程化支持。现在的浏览器已经逐步支持 Web Component 来逐步磨平这些个不足。

为了实现分而治之，我们不得不实现一套组件化体系，这套体系一方面约束开发，一方面完美地演绎分而治之的精髓。组件化体系解决了开发过程中复用的问题，当然得想办法解决运行的问题。比如当我们通过组件的方式去完成一个站点的拆分工作，会发现拆分后的组件很多，达到了分而治之的目的但同时给运行带来了不少的麻烦，这个麻烦我们是需要去解决的。所以我们的工程化体系里面有了打包 (package) 这个名词，这个名词几乎是我们工程化体系中无法抹去的一个话题，也同样是性能优化体系里面一个非常重要的手段。

在组件化的体系里面，我们可以回想一下静态编译语言或者支持模块化的语言对于模块的一个特性，比如继承、比如扩展、再比如依赖。同样我们构建的组件化体系中统一要解决这些问题。当你在开发静态编程语言 c 语言的时候，在编译阶段会有依赖错误产生，这时候你可能非常好解决这个问题，你可以按照错误去解决。另一个比较难以解决的问题是运行时发现有依赖的基础库错误，这时候就不好解决了。同样在前端的组件化体系中也同样有这样的问题。

解决依赖是个非常麻烦的事情，一般我们会在构建编译的阶段去搞定这个事情，如果静态编译想搞定这个事情需要有一套可识别的标志。这就是刚才提到的组件化体系里面对于组件的引用的设定更准确一些就叫语法（require、define、import），这也是组件化规范的一部分（比如 CommonJS、AMD、CMD、UMD），在当下 ES6 默认支持。一般都会使用路径引入模块。构建时通过分析这些语法，来获得依赖关系。依赖关系有两个用途，一方面是在合并打包的时候作为参考，另一方面在浏览器端运行时提前去加载依赖；为了解决依赖问题，有很多名词经常出现，比如依赖前置。

> 每个构建工具在解决依赖这块做法是不太一样的，有些是从根节点搜索一棵树，有些是先分析出依赖树，最后再去根据收集到的依赖决策打包。实现方式有正则方式、也有 AST 方式，当然这些都大同小异，如果感兴趣也可以自己创造一种新的方式。

加载组件以及组件的依赖，在浏览器执行阶段可以有两种方式，一种是同步加载，对于同步加载的情况一般的做法是在 HTML 上 script 标签进行外链，另外一种方式是通过 JS 动态生成 script 节点来外链或者直接 Ajax 或者 Fetch 请求代码片段再执行。这种方式也同样适用于 CSS。加载工作主要是 Loader 来完成的，所以在组件化体系中有个 JS Loader 的概念。require.js、seajs 等都有这方面的支持。再往大里面延展 Loader 的功能，解决加载、处理依赖、保证执行、保证作用域、保证各种方式的执行代码的都由一个 JS 框架完成。

分治是为了更好的开发、维护、调试，其最核心优化的是研发的效率，合并（打包）最核心优化的是浏览器端运行的效率。所以，我们工程化其中一个核心的目标就是优化效率。

> 开发阶段，我们需要的是开发体验的提升，希望用抽象的思维去看待一切，绝不去浪费时间在重复的事情上。这样的情况下孕育了各种各样的工具。比如脚手架、模拟服务、LiveReload、HMR 等等。

我们希望覆盖整个研发流程，从方方面面进行效率的提升。这就是工具这个方向的使命。

站在浏览器的视角，运行快速、准确是最终我们要达到的目标。为了这个目标，根据网页的特性，我们需要优化整个链路，包括资源的加载、代码的运行、浏览器渲染的研究、数据的获取等等。积攒了非常多的经验后，把这些经验融合到我们的工程化体系里面，把这些优化在业务开发中不可见，按照某种方式去做，然后就可以获取到最佳性能，而不需要做额外的工作。这就是架构本身的魅力，做到这一点需要有规范。

站在研发的视角，开发快、易于调试、快速上线这些是我们的目标，对于这些目标，我们同样需要有一定的规范。规范我们代码如何写更易于维护，规范我们用什么语法更快速的能够开发。

不管是组件化体系、运行时效率、研发效率都需要规范，这些规范整体归纳为我们的研发规范体系；除了规范体系，还有更多的基础设施围绕着效率展开，比如更好写的语言、更高纬度的抽象、更高效的框架等等。

> 开发的场景里面，CSS 不好写，我们就有了 Sass；JS 弱类型，我们就有了 Typescript；另外为了开发的更高效，我们有了一堆的框架，React、Vue、Angular 等等。

我们围绕研发、浏览器两个视角不停的在构建我们的工程体系，希望于把一些繁杂的事情化简、把一些固化的优化对于研发透明。

固化的方式是有可能限制创造的，所以为了达到激发创造的可能，松耦合的工程架构体系才更适用。松耦合的工程体系会造成更多的个性化，个性化就可能降低效率。所以做工程也是一个反复折中的过程，无法一蹴而就，一劳永逸。

## 工程化要解决的问题

1. 提高前端开发效率

- 扩展 `javaScript` `css` `html` 本身的语言能力
- 解决重复性工作
- 模块化、组件化
- 解决功能复用和变更问题
- 解决开发和产品环境差异问题
- 解决开发流程问题

2. 进行高效的多人协作

3. 保证项目的可维护性

4. 提高项目的开发质量
```

[精读《插件化思维》](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/53.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%8F%92%E4%BB%B6%E5%8C%96%E6%80%9D%E7%BB%B4%E3%80%8B.md)

[精读《新一代前端构建工具对比》](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/195.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%96%B0%E4%B8%80%E4%BB%A3%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94%E3%80%8B.md)

[精读《如何编译前端项目与组件》](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/89.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%8B.md)

[senntyou](https://www.jianshu.com/u/26ce9d256997)

[前端工程之模块化](http://fex.baidu.com/blog/2014/03/fis-module/)

[fouber/blog](https://github.com/fouber/blog)

[Tecvan](https://juejin.cn/user/1820446985555544/posts)

[前端编译和工程化](https://juejin.cn/column/6992030342987120677)

[你真的了解 package.json 吗？来看看吧，这可能是最全的 package 解析](https://juejin.cn/post/6987179395714646024)

[《大前端进阶 工程化》系列 P6 必备脚手架/CI 构建能力（上）](https://mp.weixin.qq.com/s/4HeDZW5ND6-7wHny0J1TQw)

[《大前端进阶 Node.js》系列 P6 必备脚手架/CI 构建能力（下）](https://mp.weixin.qq.com/s/vgcxF2MSVtbf-phfHI6GHw)

[前端工程化：如何使用 monorepo 进行多项目的高效管理](https://juejin.cn/post/7043990636751503390)

[Changesets: 流行的 Monorepo 场景发包工具](https://mp.weixin.qq.com/s/QKqaO3U1gzwWb2sDiF4cLQ)

[vite-essentials](https://github.com/zce/vite-essentials)

[谁能介绍下 web 前端工程化？](https://www.zhihu.com/question/24558375)

[新手的对于前端组件化开发的一些疑问？](https://www.zhihu.com/question/53376712)

[一个专业的『前端工程化体系』是如何建立的？](https://www.zhihu.com/question/279540558)

[你能给前端工程化下个定义么？](https://mp.weixin.qq.com/s/5w-y1eb07IqJ9zfYUwVzbQ)

[5 分钟搭一个企业级脚手架](https://mp.weixin.qq.com/s/kKStWjNqpavJYeJpiH3Byw)

[超全面的前端工程化配置指南](https://mp.weixin.qq.com/s/3_gZ9vNZixK_qZdWu9Dyhw)
