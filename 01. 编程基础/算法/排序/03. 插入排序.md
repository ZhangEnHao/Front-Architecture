插入排序算法描述的是一种简单直观的排序算法。在是简单排序中效率最好。插入排序也是学习其他高级排序的基础。

## 插入排序的思路

1. 插入排序思想的核心是局部有序:

在一个队列中的元素, 选择其中一个作为标记的元素. 这个被标记的元素左边的所有元素已经是局部有序的.这意味着, 队列中有一部门元素是按顺序排列好的. 有一部分元素还没有顺序.

通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，从而达到排序的效果。

2. 插入排序的思路:

- 从第一个元素开始，该元素可以认为已经被排序

- 取出下一个元素，在已经排序的元素序列中从后向前扫描

- 如果该元素（已排序）大于新元素，将该元素移到下一位置

- 重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置

- 将新元素插入到该位置后, 重复上面的步骤.

## 插入排序的效率

1. 插入排序的比较次数:

第一趟时, 需要的最多次数是1, 第二趟最多次数是2, 依次类推, 最后一趟是N-1次.
因此是1 + 2 + 3 + ... + N - 1 = N * (N - 1) / 2.
然而每趟发现插入点之前, 平均只有全体数据项的一半需要进行比较.
可以除以2得到 N * (N - 1) / 4. 所以相对于选择排序, 其他比较次数是少了一半的.

2. 插入排序的复制次数:

第一趟时, 需要的最多复制次数是1, 第二趟最多次数是2, 依次类推, 最后一趟是N-1次.
因此是1 + 2 + 3 + ... + N - 1 = N * (N - 1) / 2.
平均次数是 N * (N - 1) / 4

3. 对于基本有序的情况

对于已经有序或基本有序的数据来说, 插入排序要好很多.
当数据有序的时候, while循环的条件总是为假, 所以它变成了外层循环中的一个简单语句, 执行N-1次.
在这种情况下, 算法运行至需要N(N)的时间, 效率相对来说会更高.
然而比较次数是选择排序的一半, 所以这个算法的效率是高于选择排序的

## 代码实现

```javaScript
function insertSort(array) {
  const len = array.length
  let current
  let prev
  for (let i = 1; i < len; i++) {
    current = array[i]
    prev = i - 1
    while (prev >= 0 && array[prev] > current) {
      array[prev + 1] = array[prev]
      prev--
    }
    array[prev + 1] = current
  }
  return array
}
```
