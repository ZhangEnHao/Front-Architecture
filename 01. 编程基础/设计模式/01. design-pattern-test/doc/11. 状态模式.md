## 介绍

- 一个对象有状态变化

- 每次状态变化都会触发一个逻辑

- 不能总是用 ``` if...else... ``` 来控制


## 场景

1. 交通信号灯红黄绿颜色变化

```JavaScript
// 状态 红黄绿灯
class State {
  constructor(color) {
    this.color = color
  }
  handle(context) {
    console.log(`turn to ${this.color} ligth`);
    context.setState(this)
  }
}

// 主体
class Context {
  constructor() {
    this.state = null
  }
  getState() {
    return this.state
  }
  setState(state) {
    this.state = state
  }
}

// test
let context = new Context();
let red = new State("red");
let blue = new State("blue");
red.handle(context);
console.log(context.getState());

blue.handle(context);
console.log(context.getState());

```

2. 有限状态机

- 有限个状态、以及在这些状态之间的变化

- 如交通信号灯

- 使用开眼 lib：[javascript-state-machine](github.com/jakesgordon/javascript-state-machine)

3. 一个简单的 ``` Promise ``` —— 只关注状态变化

- ``` Promise ``` 三种状态： ``` pending 、 fullfilled 、rejected ```

- 状态变化：``` pending => fullfilled / pending => rejected ``` ，不能逆向变化

```JavaScript
import StateMachine from "javascript-state-machine"

// 状态机模型
let fsm = new StateMachine({
  init: "pending",
  transitions: [
    {
      name: "resolve", // 事件名称
      from: "pending",
      to: "fullfilled"
    },
    {
      name: "reject", // 事件名称
      from: "pending",
      to: "rejected"
    },
  ],
  methods: {
    // 监听 resolve
    onResolve: function(state, data) {
      // state - 当前状态机实例：data - fsm.resolve(xxx) 传递的参数
      data.successList.forEach(fn => fn())
    },
    // 监听 reject
    onReject: function(state, data) {
      // state - 当前状态机实例：data - fsm.reject(xxx) 传递的参数
      data.failList.forEach(fn => fn())
    }
  }

})

// 定义 Promise
class MyPromise {
  constructor(fn) {
    this.successList = [];
    this.failList = [];
    fn(function() {
      // resolve 函数
      fsm.resolve(this)
    }, function() {
      // reject 函数
      fsm.reject(this)
    })
  }
  then(successFn, failFn) {
    this.successList.push(successFn);
    this.failList.push(failFn);
  }
}

// test
function loadImg(src) {
  const promise = new MyPromise(function(resolve, reject) {
    let img = document.createElement("img");
    img.onload = function() {
      resolve(src)
    }
    img.onerroe = function() {
      reject()
    }
  })
  return promise
}

let src = "123.png";
let result = loadImg(src);
result.then(function() {
  console.log("ok1");
}, function() {
  console.log("fail1");
});

result.then(function() {
  console.log("ok2");
}, function() {
  console.log("fail2");
})
```

## 设计原则验证

- 将状态对象和主体对象分离，状态的变化逻辑单独处理

- 符合开放封闭原则



