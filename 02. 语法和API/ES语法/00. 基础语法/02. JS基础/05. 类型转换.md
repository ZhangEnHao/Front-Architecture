## 类型转换规则

| 转换前类型 | 转换前值        | 转换后（Boolean） | 转换后（Number） | 转换后（String）  |
| :--------- | :-------------- | :---------------- | :--------------- | :---------------- |
| Boolean    | true            | true              | 1                | "true"            |
| Boolean    | false           | false             | 0                | "false"           |
| Number     | 123             | true              | 123              | "123"             |
| Number     | Infinity        | true              | Infinity         | "Infinity"        |
| Number     | 0               | false             | 0                | "0"               |
| Number     | NaN             | false             | NaN              | "NaN"             |
| String     | ""              | false             | 0                | ""                |
| String     | "123"           | true              | 123              | "123"             |
| String     | "123TYPE"       | true              | 123              | "123TYPE"         |
| String     | "TYPE"          | true              | NaN              | "TYPE"            |
| Null       | null            | false             | 0                | "null"            |
| Undefined  | undefined       | false             | 0                | "undefined"       |
| Symbol     | Symbol()        | true              | TypeError        | TypeError         |
| Function   | function(){}    | true              | NaN              | "function(){}"    |
| Object     | {}              | true              | NaN              | "[object Object]" |
| Array      | []              | true              | 0                | ""                |
| Array      | ["TYPE"]        | true              | NaN              | "TYPE"            |
| Array      | ["123", "TYPE"] | true              | NaN              | "123,TYPE"        |

## 转 Boolean

在条件判断时，除了`undefined`，`null`，`false`，`NaN`，`''`， `0`，`-0`，其他所有值都转为 `true`，包括所有对象。

## 对象转换成基础类型

「对象」转换成「原始类型」的值，算法如下：

1.  先调用对象的 valueOf() 方法，得到返回值，返回值为原始类型则转换成功；

2.  如果返回的不是原始类型，再接着调用的 toString() 方法，得到原始类型；

3.  如果上面两步都得不到原始类型，则报错。

## 隐式转换

1. [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

常用的，从**上到下从高到低排序，同级内按书写时从左到右排序**：

- `()` 子表达式；
- `[]`、`.`成员访问，`()` 函数调用；
- `...++`、`...--` 后置递增、递减；
- `~` 按位非、`!` 逻辑非、`+...` 一元加法、`-...` 一元减法、`--...`、`++...` 前置递增、递减；
- `*` 乘法、`/` 除法、`%` 取模；
- `+`、`-` 加减法；
- `==`、`!=`、`===`、`!== `（非）相等、全等判断符；
- `&&` 逻辑与；
- `||` 逻辑或；
- `...?...:...` 三元运算；

## 加号运算符

1. 首先执行代码，调用 对象转换成基础类型 方法得到原始值；

2. 如果两个原始值都是「数字」，则直接相加得出结果。

3. 如果两个原始值都是「字符串」，把第二个字符串连接到第一个上，也就是相当于调用 concat 方法。

4. 如果只有一个原始值是「字符串」，调用 toString 方法把另一个运算数转换成「字符串」，结果是两个字符串连接成的字符串。

`javaScript
1 + '1' // '11'
2 \* '2' // 4
[1, 2] + [2, 1] // '1,22,1'
// [1, 2].toString() -> '1,2'
// [2, 1].toString() -> '2,1'
// '1,2' + '2,1' = '1,22,1'

// 对于加号需要注意这个表达式 'a' + + 'b'
'a' + + 'b' // -> "aNaN"
// 因为 + 'b' -> NaN
// 你也许在一些代码中看到过 + '1' -> 1
`

总结：只要是加号运算符，两边都转为基础类型；但是需要注意 {} 是对象还是代码块

## `{}`是对象还是代码块

一些例子：

`javaScript
{a: 1}[1] // [1]

{a: 1}['a'] // ["a"]

({a: 1})['a'] // 1

({a: 1,})['a'] // 1

{a: 1,}['a'] // Uncaught SyntaxError: Unexpected token '}'

{a, 1}[] // []
`

特点：

- 当 `{}` 前面有运算符号的时候，`+，-，*，/，()` 等等， `{}` 都会被解析成「对象字面量」；

- 当 `{}` 前面没有运算符时候但有 `;` 结尾的时候，或者浏览器的自动分号插入机制给 `{}` 后面插入分号 `;` 的时候，此时 `{}` 都会被解析成「代码块」。

验证：

`javaScript {} // {} | 对象 {}; // undefined | 代码块 +{} // NaN | 对象 {}+{} // "[object Object][object Object]" | 对象+对象 {}+{}; // NaN | 代码块+对象 `

也就是说 `{}` 后有 `;` 结尾，前无符号，`{}` 才会被翻译为「代码块」。

## 类型转换举例

`javaScript
[] + {} // "[object Object]"
{} + [] // 0

{} + 0 // 0
0 + {} // "0[object Object]
`

其中 `{} + [] = 0`开头 `{}` 并不是空对象的字面量，而是被当作空的代码块。

事实上这个表达式的值就是 `+[]` 的结果，即 `Number([].join(','))`，即为`0`。

`javaScript
{}+1 // 1
// 正确：{} 后有自动插入分号，且前无运算符，看做代码块

({}+1) // "[object Object]1"
// 错误：1，把 {} 看做代码块
// 正确：{} 前有括号，看做对象，调用对象的 `({}.toString)` 得到 `"[object Object]"`

1+{} // “1[object Object]”
// 正确：{} 前有 `+` 号，看做对象，调用对象的 `({}.toString)` 得到 `"[object Object]"`

[]+1 // "1"
// 正确：`+` 号两边转为原始类型，`[].toString()`，得到 `""`

1+[] // "1"
// 错误：1，把 [] 转换成了 Number
// 正确：`+` 号两边转为原始类型，`[].toString()`，得到 `""`

1-[] // 1
// 正确：`-` 号两边均转为 Number 类型，`Number([])` 得到 `0`

1-{} // NaN
// 正确：`-` 号两边均转为 Number 类型，`Number({})` 得到 `NaN`

1-!{} // 1
// 正确：`!` 一元逻辑非的优先级高于 `-` 二元减法，所以先进行 `![]` 运算，得到 `false`，`1-false` 将 `false` 转为 `Number` 得到 `0`

1+!{} // 1
// 正确：`!` 一元逻辑非的优先级高于 `-` 二元加法，所以先进行 `![]` 运算，得到 `false`，`1+false` 将 `false` 转为 `Number` 得到 `0`

1+"2"+"2" // "122"
// 正确：只要加号两边有一个字符串就全部转为字符串进行拼接

1+ +"2"+"2" // "32"
// 错误："122"，当做 1+ (2+"2")
// 正确：`1+` 后有空格，第一个 `+"2"` 前的 `+` 为一元加法，优先级高，相当于进行 `1+(+"2")+"2"`，得到 `1+2+"2"` 相当于 `3+"2"`

1++"2"+"2" // ReferenceError
// 错误：NaN
// 正确：++后面需要跟一个引用类型

[]==![] // true
// 错误：false，当做两边均转为 Number，一边 1 一边 0
// 正确：先进行布尔运算，得到 `[]==false` => `""==false` => `0==0`

[]===![] // false
// 正确：先进行布尔运算，得到 `[]===false`
`

一个比较少见的例子：

`javaScript {}+[]==[]+{} // true {}+[]==[]+{}; // false `

## 验证分析 ++[[]][+[]]+[+[]]==10

1. 根据优先级拆分出 + 二元加号

`javaScript
(++[[]][+[]])

- ([+[]])
  `

2. 先分析左边：++[[]][+[]]

- 1. [] 成员访问的优先级高，先计算 [[]][+[]]；

- 2. +[] 相当于 Number([])，得到 0；原式相当于 ++[[]][0]；

- 3. [[]][0] 显而易见，结果是取 [[]] 数组中的第一位，即 []；原式相当于 ++[]；

- 4. 最后来分析 ++[]。

在英文版的 ECMAScript 规范中要求（前缀、后缀）自增的内容，必须是一个引用，才不会报错(Uncaught ReferenceError: Invalid left-hand side expression in prefix operation)。

[[]][0] 是对象的属性访问，拿到的 [] 自然是一个引用；

所以，++[] 相当于 Number([])+1，得到 1。

- 5. 所以左边 ++[[]][+[]] = 1；

3. 再分析右边：[+[]]

+[] 为 0，结果为 [0]；

4. 结合左右两边式子，得到 1+[0]，其中 [0] 进行 ToPrimitive 对象转换成基础类型，得到 "0"，原式相当于 1+"0"，故得 "10"。

5. "10" == 10
